////////////////////////////////////////////////////////////////////////////////////////////
//            (C) Configuration Towards an Urban Preview - 2UP 2021                       //
//         Netherlands Environmental Assessment Agency http://www.pbl.nl/en/contact       //
//  This work is licensed under a Creative Commons Attribution 4.0 International License  //
//              CC BY-SA 4.0 https://creativecommons.org/licenses/by-sa/4.0/              //
////////////////////////////////////////////////////////////////////////////////////////////

// Author:   Bas van Bemmel
// Function:

container grid2poly
{
	unit<uint32> compactdomain := Input/CompactedDomain
	{
		attribute<Input/LatLong> point_LT    := Input/CompactedDomain/gtopo_rel[Input/LatLong];
		attribute<bool>                  IsUrban     := NewState/IsUrban;
	}

	unit<uint32> IsUrban_pol := subset(compactdomain/IsUrban)
	,	DialogType = "Map"
	,	DialogData = "poly"
	,	FreeData   = "False"
	{
		attribute<Input/LatLong> poly (poly) := points2sequence(pointset/point, pointset/sequence, pointset/ordinal);
		
		unit<uint32> pointset := union_unit(.,.,.,.,.)
		{

			//clockwise order starting from northwest
			attribute<Input/LatLong> point :=
				union_data(
					.
					, compactdomain/point_LT[nr_OrgEntity]
					, compactdomain/point_LT[nr_OrgEntity] - point(                             0.0, -Input/SourceRasterFactor, Input/LatLong)
					, compactdomain/point_LT[nr_OrgEntity] - point(Input/SourceRasterFactor, -Input/SourceRasterFactor, Input/LatLong)
					, compactdomain/point_LT[nr_OrgEntity] - point(Input/SourceRasterFactor,                               0.0, Input/LatLong)
					, compactdomain/point_LT[nr_OrgEntity]
				);
			attribute<..>     sequence :=  union_data(., id(..), id(..), id(..), id(..), id(..))[uint32];
			attribute<uint32> ordinal  :=  union_data(., const(0,..), const(1,..), const(2,..), const(3,..), const(4,..));
		}

		attribute<Input/LatLong_mdegrees> poly_mdegrees (poly) := poly[Input/LatLong_mdegrees];
		parameter<Input/LatLong_mdegrees> poly_m (poly)        := union_polygon(poly_mdegrees);


		unit<uint32> multi_polygons : nrofrows = 1
		{
			attribute<Input/LatLong_mdegrees> geometry (poly) := union_data(., poly_m);
		}

		unit<uint32> urbancluster := split_polygon(multi_polygons/geometry)
			, DialogType = "Map"
			, DialogData = "Geometry"
			{
				attribute<uint32> id:=id(.);
				attribute<Input/LatLong> centroid_or_mid  := centroid_or_mid(Geometry[/Input/LatLong])
				{
					parameter<uint32>  SymbolColor     := rgb(255,0,0),DialogType = "SymbolColor";
					parameter<int16>   SymbolIndex     := 169[int16],  DialogType = "SymbolIndex";
					parameter<float32> SymbolWorldSize := 0.02f,       DialogType = "SymbolWorldSize";
				}

				attribute<uint8>  countryrel := point_in_polygon(centroid_or_mid, /Input/administrative/Countries/Country/Geometry);
				attribute<uint32> One        := Input/administrative/Countries/Country/one[countryrel];
				attribute<string> Name_cor   := Input/administrative/Countries/Country/Name_cor[countryrel];
				attribute<string> ISO3       := Input/administrative/Countries/Country/ISO3[countryrel];
				
				attribute<uint32> nrurbancluster(Input/administrative/Countries/Country )       := sum(One,countryrel);
			}

		attribute<urbancluster> split_polygon_grid (Input/gtopo) := poly2grid(urbancluster/Geometry, Input/gtopo);

		//result already 4-connectivity cluster!
		attribute<urbancluster> urbancluster_rel (CompactedDomain)   := split_polygon_grid[/Input/CompactedDomain/gtopo_rel];

	// “Urban Centre” (also “High Density Cluster” - HDC) - An Urban Centre consists of contiguous grid
	//  cells (4-connectivity cluster) with a density of at least 1,500 inhabitants per km2
	//  of permanent land or with a built-up surface share on permanent land greater than 0.5, and has at least 50,000 inhabitants
	//  in the cluster with smoothed boundaries (NOT DONE) and <15 km2 holes filled (NOT DONE); 

		//https://ghsl.jrc.ec.europa.eu/ghs_smod2019.php
		attribute<Person>     PopInPol        (urbancluster)   := sum(NewState/Pop,urbancluster_rel);
		attribute<Person_km2> PopDensityInPol (urbancluster)   := PopInPol / (sum(Input/CompactedDomain/area ,urbancluster_rel));

		attribute<Person>     PopInPol_c        (CompactedDomain) := PopInPol[urbancluster_rel];
		attribute<Person_km2> PopDensityInPol_c (CompactedDomain) := PopDensityInPol[urbancluster_rel];


		attribute<Input/LatLong> unioned_geometry_rd (urbancluster , poly) := urbancluster/geometry[Input/LatLong];

		parameter<uint32> NrUrbanPol := count(urbancluster/nr_OrgEntity);

		//attribute<uint32> NrUrbanPol (urbancluster ) := count(urbancluster /nr_OrgEntity, urbancluster /nr_OrgEntity);
		//attribute<uint32> NrUrbanPol (urbancluster ) := const(0,urbancluster );
	}
}