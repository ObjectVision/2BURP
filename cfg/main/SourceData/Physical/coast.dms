container Coast
{
	unit<uint32> Coastline
	:  StorageName      = "%ToBURPDataDir%/physical/Coast/Coastline.shp"
	,  StorageType      = "gdal.vect"
	,  StorageReadOnly  = "True"
	{
		attribute<LatLong>           Geometry     (poly);
		attribute<SphericalMercator> Geometry_mer (arc)    := convert(Geometry, SphericalMercator);
		attribute<bool>              IsCoastline  (domain) := IsDefined(poly2grid(geometry,domain));

		unit<uint32> CoastArcSet := arc2segm(Geometry_mer)
		{
			unit<uint32> pointset := union_unit(.,.)
			{
				attribute<SphericalMercator> point    := union_data(., CoastArcSet/point, CoastArcSet/nextpoint);
				attribute<uint32>            ordinal  := union_data(., const(0,CoastArcSet), const(1,CoastArcSet));
				attribute<CoastArcSet>       sequence := union_data(., id(CoastArcSet), id(CoastArcSet));
			}
			attribute<SphericalMercator> geometry_mer_segm (arc)   := points2sequence(CoastArcSet/pointset/point, CoastArcSet/pointset/sequence, CoastArcSet/pointset/ordinal);
		}
	}
	
	attribute<Float32> Location2Coast_mer_segm   (CompactedDomain) := dist_info(Coastline/CoastArcSet/geometry_mer_segm, CompactedDomain/Geometry_mer, Sqr(250[km] / LatLong_Base/lengthdegree / CompactedDomain/lat_factor));
	attribute<km>      Location2Coast_km_CD      (CompactedDomain) := (Location2Coast_mer_segm * latlong_base/lengthdegree * CompactedDomain/lat_factor);
	attribute<km>      Location2Coast_km_domain_export    (domain) := Location2Coast_km_CD[CompactedDomain/BaseGrid], StorageName = "%LocalDataProjDir%/physical/Coast/Location2Coast_km.tif";


	unit<ipoint> Location2Coast_km
	:	StorageName     = "%ToBURPDataDir%/physical/Coast/Location2Coast_km.tif"
	,	StorageType     = "gdal.grid"
	,	StorageReadOnly = "True"
	,	DialogData      = "LatLong"
	{
		attribute<km>      GridData (domain);
		attribute<km>      ReadData (domain) := MakeDefined(GridData,250[km]);
		attribute<float32> Coastline(domain) := min_elem(ReadData,250f);//null-->250, INF=Infinity -->250

		unit<uint32> Country:= SourceData/RegionalUnits/Countries 
		{
			attribute<uint32>  sumCoastline  := sum(Coastline,per_grid)[uint32];
			attribute<uint32>  MeanCoastline := mean(Coastline,per_grid)[uint32];
			attribute<uint32>  MinCoastline  := min(Coastline,per_grid)[uint32];
			attribute<uint32>  MaxCoastline  := max(Coastline,per_grid)[uint32];
			attribute<uint32>  SDCoastline   := sd(Coastline,per_grid)[uint32];
		}
	}
}