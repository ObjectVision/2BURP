container Coast
{
	unit<uint32> Coastline_from_Countries
	:  StorageName      = "%ToBURPDataDir%/physical/Coast/DISSOLVE_countries_GADM_2012_UCD_v10_union_no_gaps_single_part.shp"
	,  StorageType      = "gdal.vect"
	,  StorageReadOnly  = "True"
	{
		attribute<LatLong>           Geometry(poly);
		attribute<SphericalMercator> Geometry_mer (arc):= convert(Geometry, SphericalMercator);

		unit<uint32> CoastArcSet := arc2segm(Geometry_mer)
		{
			unit<uint32> pointset := union_unit(.,.)
			{
				attribute<SphericalMercator> point    := union_data(., CoastArcSet/point, CoastArcSet/nextpoint);
				attribute<uint32>            ordinal  := union_data(., const(0,CoastArcSet), const(1,CoastArcSet));
				attribute<CoastArcSet>       sequence := union_data(., id(CoastArcSet), id(CoastArcSet));
			}
			attribute<SphericalMercator> geometry_mer_segm (arc)   := points2sequence(CoastArcSet/pointset/point, CoastArcSet/pointset/sequence, CoastArcSet/pointset/ordinal);
		}
	}
	
	attribute<Float32> Location2Coast_mer_segm   (CompactedDomain) := dist_info(Coastline_from_Countries/CoastArcSet/geometry_mer_segm, CompactedDomain/Geometry_mer, Sqr(250[km] / LatLong_Base/lengthdegree / CompactedDomain/lat_factor));    
	attribute<km>      Location2Coast_km         (CompactedDomain) := (Location2Coast_mer_segm * lengthdegree * CompactedDomain/lat_factor);
	attribute<km>      Location2Coast_km_domain_export    (domain) := Location2Coast_km[CompactedDomain/BaseGrid], StorageName = "%LocalDataProjDir%/physical/Coast/Location2Coast_km.tif";


	container Coastline_Distance_grid
	{
		unit<ipoint> Coastline
		:	StorageName     = "%ToBURPDataDir%/physical/Coast/Location2Coast_km.tif"
		,	StorageType     = "gdal.grid"
		,	Source          = "item /Input/Physical/Coast/Location2Coast_km_domain_export geodms 7.312 PD 7677 SD 7670 (before the commit of this file itself) caltime 3 hours 22 minutes"
		,	StorageReadOnly = "True"
		,	DialogData      = "LatLong"
		{
			attribute<float32> ReadData(domain);
			attribute<float32> Coastline(domain)    := min_elem(MakeDefined(ReadData,250f),250f);//null-->250, INF=Infinity -->250

			unit<uint8> Country:= SourceData/RegionalUnits/Countries/Country 
			{
				attribute<uint32>  sumCoastline  := sum(Coastline,SourceData/RegionalUnits/Countries/Country_grid);
				attribute<uint32>  MeanCoastline := mean(Coastline,SourceData/RegionalUnits/Countries/Country_grid);
				attribute<uint32>  MinCoastline  := min(Coastline,SourceData/RegionalUnits/Countries/Country_grid);
				attribute<uint32>  MaxCoastline  := max(Coastline,SourceData/RegionalUnits/Countries/Country_grid);
				attribute<uint32>  SDCoastline   := sd(Coastline,SourceData/RegionalUnits/Countries/Country_grid);
			}
		}
	}
}