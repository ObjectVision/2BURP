container Physical : using = "geography"
{
	unit<ipoint> Elevation
	:	StorageName     = "%ToBURPDataDir%/physical/Elevation/gtopo30_NOAA_NGDC.tif"
	,	StorageType     = "gdal.grid"
	,	url             = "https://en.wikipedia.org/wiki/GTOPO30"
	,	Source          = "National Geophysical Data Center - NOAA Data Type:File Geodatabase Raster Dataset, Database: Y:\\data\\PBLbase\\Data\\MondiaalRelief.gdb, Raster: gtopo30_NOAA_NGDC"
						  "conversion to tif-format in ArcGIS, 16_BIT_SIGNED, LZW-compression"
	,	StorageReadOnly = "True"
	,	DialogData      = "LatLong"
	{
		attribute<int16> ReadData(domain);
		attribute<bool>  NoData(domain)   :=!IsDefined(ReadData);//visualtion purposes of nodata (null) values
		attribute<int16> Elevation(domain):=MakeDefined(ReadData,0s);//0--> oceans/seas - no inland lakes! essential for rank there are values otherwise null in Urban_Cali --> moving of cururb
	}	
	
	unit<ipoint> Elevation_new
	:	StorageName     = "%ToBURPDataDir%/physical/Elevation/GLO_90_3ss_4326.tif"
	,	StorageType     = "gdal.grid"
	,	StorageReadOnly = "True"
	,	DialogData      = "LatLong"
	, 	LazyCalculated  = "true"
	{
		attribute<int32> ReadData (domain_sub);
	}
	
	unit<ipoint> TerrainRoughnessIndex := domain_sub
	{
		attribute<int32>       Elevation     (CompactedDomainSub) := Physical/Elevation_new/ReadData[CompactedDomainSub/org_rel];
		attribute<int32>       TRI_sqr_CD    (CompactedDomainSub) := sum(sqr(Elevation[CdomainSub_x_pot1k/first_rel] - Elevation[CdomainSub_x_pot1k/third_rel]), CdomainSub_x_pot1k/first_rel);
		attribute<int32>       TRI_sqr                            := recollect_by_cond(domain_sub/domain_rel->IsCompactedDomain, TRI_sqr_CD);
		
		attribute<TRI_Classes> TRI_K_rel                          := Classify(TRI_sqr, TRI_Classes/ClassBreaks_sqr);
		attribute<float32>     TRI_mean_1k               (domain) := mean(float32(TRI_K_rel), domain_sub/domain_rel);
		
		attribute<TRI_Classes> Write_TRI_Class_mean_1k   (domain) := TRI_mean_1k[TRI_Classes], StorageName = "='%ToBURPDataDir%/physical/TRI_mean_1k/'+ModelParameters/StudyArea+'.tif'";
		attribute<TRI_Classes> TRI_Class_mean_1k         (domain) : StorageName     = "= PropValue(Write_TRI_Class_mean_1k, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", LazyCalculated = "True";
		
		parameter<string>      Generate                           := 'Ready', ExplicitSuppliers = "Write_TRI_Class_mean_1k";
		
		unit<uint8> TRI_Classes : nrofrows = 7
		{
			attribute<uint8>   Class             := id(.) + 1b;
			attribute<string>  label             : ['level surface', 'nearly level surface', 'slightly rugged surface', 'intermediately rugged surface', 'moderately rugged surface', 'highly rugged surface', 'extremely rugged surface'];
			attribute<float32> ClassBreaks_org   : [0, 81, 117, 162, 240, 498, 959];
			attribute<int32>   ClassBreaks_sqr   := int32(sqr(ClassBreaks_org));
 		}
		
		container Read_PerContinentFiles :=
			for_each_ndnvat(
				Classifications/Continents/name
				, Domain_perContinent
				, Classifications/Continents/name
				, TRI_Classes
				, '%ToBURPDataDir%/physical/TRI_mean_1k/'+Classifications/Continents/name+'.tif'
				, 'gdal.grid'
			);
			
			

		container MakeDomain_perContinent :=
			for_each_ne(
				Classifications/Continents/name
				, 'MakeDomain_perContinent_T('+quote(Classifications/Continents/name)+')'
			);
			
		container Domain_perContinent :=
			for_each_nex(
				Classifications/Continents/name
				, 'MakeDomain_perContinent/'+Classifications/Continents/name+'/domain'
				, wpoint
			);
			
		
		Template MakeDomain_perContinent_T
		{
			parameter<string> Continent_name;
			///
			
			unit<uint32> StudyAreaTile: StorageName = "='%projdir%/data/StudyAreaTiles_'+Continent_name+'.dbf'", StorageReadOnly = "true", FreeData = "False"
			{
				attribute<int32>            LB_X;
				attribute<int32>            LB_y;
				attribute<int32>            UB_X;
				attribute<int32>            UB_y;
				attribute<int32>            LB_sub_X;
				attribute<int32>            LB_sub_y;
				attribute<int32>            UB_sub_X;
				attribute<int32>            UB_sub_y;
				
				attribute<ProtoDomain>      LB    := point_yx(uint16(LB_y), uint16(LB_x), ProtoDomain);
				attribute<ProtoDomain>      UB    := point_yx(uint16(UB_y), uint16(UB_x), ProtoDomain);
				
				attribute<ProtoDomain_sub>  LB_sub    := point_yx(LB_sub_y, LB_sub_x, ProtoDomain_sub);
				attribute<ProtoDomain_sub>  UB_sub    := point_yx(UB_sub_y, UB_sub_x, ProtoDomain_sub);
			} 

			unit<wpoint> domain := TiledUnit(StudyAreaTile/LB, StudyAreaTile/UB)
			{
				unit<uint16> rowset := range(uint16, pointrow(Lowerbound(domain)), pointrow(Upperbound(domain)))
				{
					attribute<float64> lat_top         := pointrow( point_yx(ID(.), const(0w, .), domain)[LatLong] );
					attribute<float64> lat_mid         := lat_top  + 0.5 * pointrow(getprojectionfactor(domain)[LatLong]);
					attribute<Float32> lat_factor      := Float32( cos(lat_mid * 2d*pi() / 360d ) );
					parameter<km2>     Equatorial_Area := sqr(Float32(pointrow(getprojectionfactor(domain)[LatLong])) * LatLong_base/lengthdegree);
					attribute<km2>     area            := lat_factor * Equatorial_Area;
				}
				
				attribute<LatLong>        geometry      := id(.)[LatLong];
				attribute<Mollweide_grid> mollweide_rel := convert(geometry, Mollweide_grid);
				attribute<WebMercator_grid> webmercator_rel:= convert(geometry, WebMercator_grid);

				parameter<uint32>  boundrange_c := uint32(PointCol(boundrange(domain)));
				attribute<Float32> lat_factor   := rowset/lat_factor[pointrow(ID(.))];
				attribute<km2>     area         := rowset/area[pointrow(ID(.))]; //use rowset area
			}
		}
	}
	
	unit<ipoint> Slope_2021
	:	StorageName = "%ToBURPDataDir%/physical/Slope/gtopo30_degree_planar_zfactor1_ag1061_exportgeodms.tif"
	,	StorageType = "gdal.grid"
	,	url         = "%ToBURPDataDir%/physical/slope/USGS EROS Archive - Digital Elevation - Global Multi-resolution Terrain Elevation Data 2010 (GMTED2010).html"
	,	Source      = "DEM: Database: 	Y:\data\PBLbase\Data\MondiaalRelief.gdb Raster: 	gtopo30_NOAA_NGDC"
					  "Slope genereated in ArcGIS 10.6.1 from Slope-syntax DEM in degrees, planar, zfactor1  --> gtopo30_degree_planar_zfactor1_ag1061.tif"
					  "GeoDMS -3.40282E+38f has been given value 0 --> exported as tif"
	,	StorageReadOnly = "True"
	,	DialogData      = "LatLong"
	{
		attribute<float32> ReadData (domain);
	}	
	
	unit<ipoint> SnowIceCover
	:	StorageName     = "%ToBURPDataDir%/physical/SnowIceCover/Modis2001_SnowIce_unint2_2.tif"
	,	StorageType     = "gdal.grid"
	,	url             = "%ToBURPDataDir%/physical/MCD12Q1_UserGuide_07302013.pdf"//MODIS Web
	,	Source          = "Database: Y:\Data\PBLbase\Data\MODIS_BOS.gdb\MODIS_2001_BOS"
						  "conversion to tif-format in ArcGIS, unsigned integer 2 Bit, LZW-compression with correct extent"
	,	StorageReadOnly = "True"
	,	DialogData      = "LatLong"
	{
		attribute<uint8> ReadData (domain);
	}	
	
	#include <coast.dms>
	#include <natural_hazards.dms>
	
	container Water : using = "geography"
	{
		unit<uint32> Inland_Water
		:  StorageName      = "%ToBURPDataDir%/physical/Water/InlandWater.shp"
		,  StorageType      = "gdal.vect"
		,  StorageReadOnly  = "True"
		{
			attribute<LatLong>           Geometry(poly);
			attribute<m2>                Area                    := area(Geometry[WorldMollweide], float64)[m2];
			attribute<bool>              Write_per_grid (domain) := IsDefined(poly2grid(Inland_Water/geometry, domain)), StorageName = "= '%ToBURPDataDir%/physical/Water/'+ModelParameters/StudyArea+'/IsInlandWater.tif'";
			attribute<bool>              Read_per_grid  (domain) : StorageName = "=PropValue(Write_per_grid, 'StorageName')", StorageReadOnly = "true";
			
			attribute<bool>              Write_per_subgrid (domain_sub) := IsDefined(poly2grid(Inland_Water/geometry, domain_sub)), StorageName = "= '%ToBURPDataDir%/physical/Water/'+ModelParameters/StudyArea+'/IsInlandWater_subdomain.tif'";
			attribute<bool>              Read_per_subgrid  (domain_sub) : StorageName = "=PropValue(Write_per_subgrid, 'StorageName')", StorageReadOnly = "true";
		}

		#include <rivers.dms> // dms file kan evt gedelete? ligt aan calibratie
		#include <lakes.dms> // dms file kan evt gedelete? ligt aan calibratie
		#include <floodProneArea.dms>
		
		container AllWater
		{
			attribute<bool>   LandMass      (domain_sub) := Coast/Coastline/Read_per_subgrid;
			attribute<bool>   IsInlandWater (domain_sub) := Water/Inland_Water/Read_per_subgrid;
			attribute<bool>   IsOcean       (domain_sub) := not(LandMass);
			attribute<bool>   IsWater       (domain_sub) := IsInlandWater || IsOcean;
			
			attribute<uint32> Fraction_InlandWater0  (domain) := sum(IsInlandWater[uint32], domain_sub/domain_rel);
			attribute<uint32> Fraction_InlandWater   (domain) := ((Fraction_InlandWater0[float32] / 36f) * 100f)[uint32];
			
			attribute<uint32> Fraction_Water0  (domain) := sum(IsWater[uint32], domain_sub/domain_rel);
			attribute<uint32> Fraction_Water   (domain) := ((Fraction_Water0[float32] / 36f) * 100f)[uint32];
			
			//attribute<float32>inv_dist_all_inland_water (domain):= 1f / proximity(float32(Fraction_InlandWater>0), Distmatrices/pot250km/inv_EDM), StorageName = "= '%ToBURPDataDir%/Physical/water/'+ModelParameters/StudyArea+'/Location2AnyInland_km.tif'";
			//attribute<float32>inv_dist_large_inland_water (domain):= 1f / proximity(float32(Fraction_InlandWater>50), Distmatrices/pot250km/inv_EDM), StorageName = "= '%ToBURPDataDir%/Physical/water/'+ModelParameters/StudyArea+'/Location2AnyInland_km.tif'";
			
			//unit<ipoint> Dist_AllInland_km: StorageName     = "= PropValue(inv_dist_all_inland_water, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", DialogData      = "LatLong" {attribute<km> GridData (domain);}
			//unit<ipoint> Dist_LargeInland_km: StorageName     = "= PropValue(inv_dist_large_inland_water, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", DialogData      = "LatLong" {attribute<km> GridData (domain);}
			
			unit<uint32> large_inland_water:= select_with_org_rel(Inland_Water/area[km2] > 0.5[km2]) 
			{
				attribute<SphericalMercator> geometry_mer (polygon):= org_rel->Geometry[SphericalMercator];
			}
			attribute<Float32> sqr_dist                				(CompactedDomain) := Sqr(250000[meter] / CompactedDomain/lat_factor);
			
			attribute<Float32> Location2AllInland_distInfo (CompactedDomain) := dist_info(Inland_Water/Geometry[SphericalMercator], CompactedDomain/Geometry_mer, sqr_dist);
			attribute<km>      Location2AllInland_km       (CompactedDomain) := (Location2AllInland_distInfo * CompactedDomain/lat_factor)[meter] * 0.001[km / meter];
			attribute<km>      Location2AllInland_km_domain_export (domain) := min_elem(Location2AllInland_km[CompactedDomain/BaseGrid], 250[km]), StorageName = "= '%ToBURPDataDir%/Physical/water/'+ModelParameters/StudyArea+'/Location2AnyInland_km.tif'";
			
			attribute<Float32> Location2LargeInland_distInfo (CompactedDomain) := dist_info(large_inland_water/geometry_mer, CompactedDomain/Geometry_mer, sqr_dist);
			attribute<km>      Location2LargeInland_km       (CompactedDomain) := (Location2LargeInland_distInfo * CompactedDomain/lat_factor)[meter] * 0.001[km / meter];
			attribute<km>      Location2LargeInland_km_domain_export (domain) := min_elem(Location2LargeInland_km[CompactedDomain/BaseGrid], 250[km]), StorageName = "= '%ToBURPDataDir%/Physical/water/'+ModelParameters/StudyArea+'/Location2LargeInland_km.tif'";
			
			unit<ipoint> Dist_AllInland_km: StorageName     = "= PropValue(Location2AllInland_km_domain_export, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", DialogData      = "LatLong" {attribute<km> GridData (domain);}
			unit<ipoint> Dist_LargeInland_km: StorageName     = "= PropValue(Location2LargeInland_km_domain_export, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", DialogData      = "LatLong" {attribute<km> GridData (domain);}
			
			
		/*	unit<uint32> all_inland_water:= select_with_org_rel(Fraction_InlandWater>0) {
				attribute<LatLong>           Geometry:= org_rel[LatLong];
				attribute<SphericalMercator> geometry_mer:= Geometry[SphericalMercator];
			}
			unit<uint32> large_inland_water:= select_with_org_rel(Fraction_InlandWater>50) {
				attribute<LatLong>           Geometry:= org_rel[LatLong];
				attribute<SphericalMercator> geometry_mer:= Geometry[SphericalMercator];
			}
			attribute<Float32> sqr_dist                				(CompactedDomain) := Sqr(250000[meter] / CompactedDomain/lat_factor);
			attribute<all_inland_water> Location2AllInland_dest 	(CompactedDomain) := connect(all_inland_water/geometry_mer, CompactedDomain/Geometry_mer);
			attribute<km>      Location2AllInland_km       			(CompactedDomain) := (dist(CompactedDomain/Geometry_mer, all_inland_water/geometry_mer[Location2AllInland_dest]) * CompactedDomain/lat_factor[float64])[meter] * 0.001[km / meter];
			attribute<km>      Location2AllInland_km_domain_export  (domain) :=	min_elem(Location2AllInland_km[CompactedDomain/BaseGrid], 250[km]), StorageName = "= '%ToBURPDataDir%/Physical/water/'+ModelParameters/StudyArea+'/Location2AnyInland_km.tif'";
			attribute<large_inland_water> Location2LargeInland_distInfo 		(CompactedDomain) := connect(large_inland_water/geometry_mer, CompactedDomain/Geometry_mer);
			attribute<km>      Location2LargeInland_km       		(CompactedDomain) := (dist(CompactedDomain/Geometry_mer, large_inland_water/geometry_mer[Location2LargeInland_distInfo]) * CompactedDomain/lat_factor[float64])[meter] * 0.001[km / meter];
			attribute<km>      Location2LargeInland_km_domain_export(domain) := min_elem(Location2LargeInland_km[CompactedDomain/BaseGrid], 250[km]), StorageName = "= '%ToBURPDataDir%/Physical/water/'+ModelParameters/StudyArea+'/Location2LargeInland_km.tif'";
			
			unit<ipoint> Dist_AllInland_km: StorageName     = "= PropValue(Location2AllInland_km_domain_export, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", DialogData      = "LatLong" {attribute<km> GridData (domain);}
			unit<ipoint> Dist_LargeInland_km: StorageName     = "= PropValue(Location2LargeInland_km_domain_export, 'storagename')", StorageType     = "gdal.grid", StorageReadOnly = "True", DialogData      = "LatLong" {attribute<km> GridData (domain);}
			*/
		}
	}
}