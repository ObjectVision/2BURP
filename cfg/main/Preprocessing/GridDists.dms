Container GridDists: using = "Geography;SourceData;" {
	
	parameter<string> sett_folder:= 'all_settlements_SMOD_V1s6_opr_P2023_v1_2000/';
	
	unit<uint32> settlements: nrofrows = 6 {attribute<string> label: ['Africa_point', 'Asia_point', 'Australia_Oceania_point', 'Europe_point', 'North_America_point', 'South_America_point'];}
	
	container load_settlements:= for_each_ne(settlements/label, 'T_loadpointfile('+quote(sett_folder+settlements/label)+')') {
		unit<uint32> all_settlements:= ='union_unit('+asitemlist(settlements/label+'/inFile')+')' {
			attribute<LatLong> Geometry:= ='union_data(.,'+asitemlist(settlements/label+'/inFile/Geometry')+')';
			attribute<string> Label:= ='union_data(.,'+asitemlist(settlements/label+'/inFile/Label')+')';
			attribute<uint32> type:= switch(case(strcount(Label, 'sdt') > 0, 22), case(strcount(Label, 'town') > 0, 23), case(strcount(Label, 'city') > 0, 30), 13);
			attribute<uint32> L_15min:= ='union_data(.,'+asitemlist(settlements/label+'/inFile/L_15min')+')';
			attribute<uint32> L_30min:= ='union_data(.,'+asitemlist(settlements/label+'/inFile/L_30min')+')';
			attribute<uint32> L_60min:= ='union_data(.,'+asitemlist(settlements/label+'/inFile/L_60min')+')';
			attribute<grid>   grid_rel:= Geometry[grid];
			attribute<NodeSet>NodeSet_rel:= grid/NodeSet_rel[grid_rel];
		}	
	}
	
	unit<wpoint> grid:= Geography/domain {
		attribute<float32> 	Roughness:= Physical/TerrainRoughnessIndex/mean;
		attribute<bool> 	InWater:= Roughness = 0f || !GridData/IsNotLake;
		attribute<float32>	Impedance:= Roughness^2f + (10f * InWater[float32]);
		attribute<NodeSet>  NodeSet_rel:= invert(NodeSet/Nr_OrgEntity);
		
		attribute<NodeSet> N                   (domain) := NodeSet_rel[(id(.)) - point(1w, 0w, wpoint)];
		attribute<NodeSet> NE                  (domain) := NodeSet_rel[(id(.)) - point(1w, 0w, wpoint) + point(0w, 1w, wpoint)];
		attribute<NodeSet> E                   (domain) := NodeSet_rel[(id(.)) + point(0w, 1w, wpoint)];
		attribute<NodeSet> SE                  (domain) := NodeSet_rel[(id(.)) + point(1w, 1w, wpoint)];
				
		unit<uint32> all_Ns:= subset(isdefined(NodeSet_rel) && isdefined(N)) {attribute<NodeSet> F2:= grid/N[Nr_OrgEntity]; attribute<float32> L:= const(1f,.,float32);}
		unit<uint32> all_NEs:= subset(isdefined(NodeSet_rel) && isdefined(NE)) {attribute<NodeSet> F2:= grid/NE[Nr_OrgEntity]; attribute<float32> L:= const(1.414213562f,.,float32);} // square root of 2 (given 1km grids)
		unit<uint32> all_Es:= subset(isdefined(NodeSet_rel) && isdefined(E)) {attribute<NodeSet> F2:= grid/E[Nr_OrgEntity]; attribute<float32> L:= const(1f,.,float32);}
		unit<uint32> all_SEs:= subset(isdefined(NodeSet_rel) && isdefined(SE)) {attribute<NodeSet> F2:= grid/SE[Nr_OrgEntity]; attribute<float32> L:= const(1.414213562f,.,float32);} // square root of 2 (given 1km grids)}
	}
		
	unit<uint32> NodeSet:= subset(GridData/InRegion) {
		attribute<LatLong>  Geometry:= Nr_OrgEntity[LatLong];
		attribute<float32> 	Roughness:= grid/Roughness[Nr_OrgEntity];
		attribute<bool>		InWater:= grid/Inwater[Nr_OrgEntity];
		attribute<float32>	Impedance:= MakeDefined(Roughness^2f, 10f) + (10f * InWater[float32]);
		attribute<float32>  EastWest_correction:= const(1f,.,float32);
		//attribute<bool>		N:= 
	}
	
	unit<uint32> Network:= union_unit(grid/all_Ns, grid/all_NEs, grid/all_Es, grid/all_SEs) {
		attribute<NodeSet> F1:= union_data(., grid/NodeSet_rel[grid/all_Ns/Nr_OrgEntity], grid/NodeSet_rel[grid/all_NEs/Nr_OrgEntity], grid/NodeSet_rel[grid/all_Es/Nr_OrgEntity], grid/NodeSet_rel[grid/all_SEs/Nr_OrgEntity]);
		attribute<NodeSet> F2:= union_data(., grid/all_Ns/F2, grid/all_NEs/F2, grid/all_Es/F2, grid/all_SEs/F2);
		attribute<float32> Length:= union_data(.,  grid/all_Ns/L, grid/all_NEs/L, grid/all_Es/L, grid/all_SEs/L);
		attribute<float32> Impedance:= Length * (NodeSet/Impedance[F1] + NodeSet/Impedance[F2]);
	}
	
	unit<uint32> access_variants: nrofrows = 6 {
		attribute<string> label: ['villages', 'towns', 'cities', 'loc_ctr', 'reg_ctr', 'nat_ctr'];
		attribute<string> def: ['uint32(SelectedSettlements/type) > 10', 'uint32(SelectedSettlements/type) > 22', 'uint32(SelectedSettlements/type) > 29', 'bool(SelectedSettlements/L_15min)', 'bool(SelectedSettlements/L_30min)','bool(SelectedSettlements/L_60min)'];
	}
	
	container AccessGrids:= for_each_ne(access_variants/label, 'T_getAccessGrids('+string(id(access_variants))+')');
	
	Template T_getAccessGrids {
		parameter<access_variants> invariant;
		
		unit<uint32> SelectedSettlements:= load_settlements/all_settlements;
		
		unit<uint32> origins:= ='subset('+access_variants/def[invariant]+' && IsDefined(SelectedSettlements/NodeSet_rel))' {
			attribute<LatLong> Geometry:= SelectedSettlements/Geometry[Nr_OrgEntity];
			attribute<NodeSet> NodeSet_rel:= SelectedSettlements/NodeSet_rel[Nr_OrgEntity];
		}
		unit<uint32> Matrix := 
			impedance_matrix(
				//'bidirectional;startPoint(Node_rel);alternative(link_imp):alt_imp'
				//'bidirectional;startPoint(Node_rel);endPoint(Node_rel);limit(OrgZone_max_mass,DstZone_mass)'
				'bidirectional;startPoint(Node_rel);endPoint(Node_rel);limit(OrgZone_max_mass,DstZone_mass);alternative(link_imp):alt_imp;od:impedance,OrgZone_rel,DstZone_rel'
				, Network/Impedance
				, Network/F1
				, Network/F2
				, id(NodeSet)
				, origins/NodeSet_rel
				, 1f, 1f
				, Network/Length
			);
		
		attribute<float32> costsgrid (grid):= min(Matrix/Impedance, Matrix/OrgZone_rel)[grid/NodeSet_rel];
		attribute<float32> distancegrid (grid):= min(Matrix/Alt_imp, Matrix/OrgZone_rel)[grid/NodeSet_rel];
		
		
	}
	
	
	Template T_loadpointfile {
		parameter<string> inpath;
		
		unit<uint32> inFile: storagename = "= '%ToBURPDataDir%/Socioeconomic/Settlements/'+inpath+'.shp'", storagereadonly = "true", storagetype = "gdal.vect" {
			attribute<LatLong> Geometry;
			attribute<string>  label;
			attribute<uint32>  L_15min;
			attribute<uint32>  L_30min;
			attribute<uint32>  L_60min;
		}
	}

}