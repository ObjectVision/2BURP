Container Calculate_DegreeOfUrbanisation : using = "Geography;SourceData;"
, URL = "https://ghsl.jrc.ec.europa.eu/degurbaDefinitions.php" 
{	
	container Parameters
	{
		container Urban_Centre
		{
			parameter<Person_km2>        Min_Density                   := 1500[Person_km2];
			parameter<Person>            Min_Total_Pop                 := 50000[Person];
			parameter<float32>           Min_Additional_BU_Share       := 0.5f;
			parameter<float32>           Max_GapFill_Area              := 15[km2];
		}
		container Dense_Urban_Cluster
		{
			parameter<Person_km2>        Min_Density                   := 1500[Person_km2];
			parameter<float32>           Min_BU_Share                  := 0.5f;
			parameter<Person>            Min_Total_Pop                 := 5000[Person];
		}
		container Semi_Dense_Urban_Cluster
		{
			parameter<Person_km2>        Min_Density_low               := 900[Person_km2];
			parameter<Person_km2>        Min_Density_high              := 1500[Person_km2];
			parameter<float32>           Min_BU_Share_low              := 0.03f;
			parameter<float32>           Min_BU_Share_high             := 0.5f;
			parameter<Person>            Min_Total_Pop                 := 2500[Person];
		}
		container Suburban_Grid_Cell
		{
			parameter<Person_km2>        Min_Density_low               := 300[Person_km2];
			parameter<Person_km2>        Min_Density_high              := 1500[Person_km2];
			parameter<float32>           Min_BU_Share_low              := 0.03f;
			parameter<float32>           Min_BU_Share_high             := 0.5f;
			parameter<Person>            Min_Total_Pop                 := 5000[Person];
		}
		container Rural_Cluster
		{
			parameter<Person_km2>        Min_Density                   := 300[Person_km2];
			parameter<Person>            Min_Total_Pop                 := 500[Person];
			parameter<float32>           Min_BU_Share                  := 0.5f;
		}
		container Low_Density_Rural_Grid_Cell
		{
			parameter<Person_km2>        Min_Density                   := 50[Person_km2];
		}
	}

	Template Gen_T
	{
		
		attribute<BuiltUpKm2>        BuiltUp_Total (domain);
		attribute<BuiltUpKm2>        BuiltUp_Residential (domain);
		attribute<Person>            Population_domain (domain);
		///
		
		attribute<km2>               Land_Area_domain                        (domain) := domain/area;
		attribute<BuiltUpKm2>        BuiltUp_Total_Area_domain               (domain) := BuiltUp_Total;
		attribute<Person_km2>        Population_Land_Density_domain          (domain) := Population_domain / Land_Area_domain; // DO NOT USE!
		attribute<BuiltUpKm2>        BuiltUp_Total_Area             (CompactedDomain) := BuiltUp_Total_Area_domain[CompactedDomain/org_rel]; 
		attribute<Person_km2>        Population_Land_Density        (CompactedDomain) := Population_Land_Density_domain[CompactedDomain/org_rel];
		attribute<km2>               Land_Area                      (CompactedDomain) := Land_Area_domain[CompactedDomain/org_rel];

		// URBAN CENTRE: Typology 30 is defined as: all cells with a local population density of at least 1,500 people/km2 or with a local built-up area share of at least 0.50, and clustered in a 4-connectivity object of at least 50,000 people or all cells resulting from 3x3 median filtering or by gap filling < 15 km2 (median filtering and gap filling applied to cluster of cells that met the previous logics)
		container Urban_Centre
		{
			container Parameters := Calculate_DegreeOfUrbanisation/Parameters/Urban_Centre;
			// pop density >= 1500 person per km2 || BU share >= 0.5
			attribute<bool>        Has_Min_PopDensity                       (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density;
			attribute<bool>        Has_Min_BUShare                          (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_Additional_BU_Share; 
			attribute<bool>        IsDenseEnoughOrBuiltupEnough             (CompactedDomain) := Has_Min_PopDensity || Has_Min_BUShare;
			
			// Clustered to total pop >= 50,000 persons
			unit<uint32> FindContiguousCells := district(uint8(recollect_by_cond(domain/IsCompactedDomain, IsDenseEnoughOrBuiltupEnough)))
			{
				attribute<.>       GroupDomain_rel                                   (domain) := districts;
				attribute<uint32>  GroupCellSize                                     (domain) := pcount_uint32(districts)[GroupDomain_rel];
				attribute<Person>  Sum_Population_perGroup                                    := sum(Population_domain,GroupDomain_rel);
				attribute<Person>  GroupPopulationSize                               (domain) := GroupCellSize != max(GroupCellSize) ? Sum_Population_perGroup[GroupDomain_rel] : null_f;
			}
			
			attribute<bool>        IsLargeEnoughGroup                       (CompactedDomain) := FindContiguousCells/GroupPopulationSize[CompactedDomain/domain_rel] >= Parameters/Min_Total_Pop;
		
			// All cells resulting from 3x3 median filtering 
			attribute<bool>        ToBeAdded_DueToMedianFiltering           (CompactedDomain) := modus(IsLargeEnoughGroup[DistMatrices/Cdomain_x_pot1k/third_rel], DistMatrices/Cdomain_x_pot1k/first_rel); 
			
			// Gap filling: lake < 15km2
			unit<uint32> GapFilling := district(uint8(recollect_by_cond(domain/IsCompactedDomain, IsLargeEnoughGroup)))
			{
				attribute<.>       GroupDomain_rel                                   (domain) := districts;
				attribute<km2>     GroupArea                                                  := sum(Land_Area_domain, GroupDomain_rel);
			}
			
			attribute<bool>        ToBeAdded_DueToGapFilling                (CompactedDomain) := (GapFilling/GroupArea[GapFilling/GroupDomain_rel])[CompactedDomain/domain_rel] < Parameters/Max_GapFill_Area;
			
			attribute<bool>        Result                                   (CompactedDomain) := IsLargeEnoughGroup || ToBeAdded_DueToMedianFiltering || ToBeAdded_DueToGapFilling;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/urban_centre : null_b;
		}
		
		// DENSE URBAN CLUSTER: Typology 23 is defined as: all cells with a local population density of at least 1,500 people/km2 or with a local built-up area share of at least 0.50, and clustered in a 4-connectivity object of at least 5,000 people and are not typology 30
		container Dense_Urban_Cluster
		{
			container Parameters := Calculate_DegreeOfUrbanisation/Parameters/Dense_Urban_Cluster;
			
			attribute<bool>        Has_Min_PopDensity                       (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density;
			attribute<bool>        Has_Min_BUShare                          (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_BU_Share; 
			attribute<bool>        IsDenseEnoughOrBuiltupEnough             (CompactedDomain) := Has_Min_PopDensity || Has_Min_BUShare;
			
			unit<uint32> FindContiguousCells := district(uint8(recollect_by_cond(domain/IsCompactedDomain, IsDenseEnoughOrBuiltupEnough)))
			{
				attribute<.>       GroupDomain_rel                                   (domain) := districts;
				attribute<uint32>  GroupCellSize                                     (domain) := pcount_uint32(districts)[GroupDomain_rel];
				attribute<Person>  Sum_Population_perGroup                                    := sum(Population_domain, GroupDomain_rel);
				attribute<Person>  GroupPopulationSize                               (domain) := GroupCellSize != max(GroupCellSize) ? Sum_Population_perGroup[GroupDomain_rel] : null_f;
			}
			
			attribute<bool>        IsLargeEnoughGroup                       (CompactedDomain) := FindContiguousCells/GroupPopulationSize[CompactedDomain/domain_rel] >= Parameters/Min_Total_Pop;
			
			attribute<bool>        IsNotUrbanCentre                         (CompactedDomain) := NOT(Urban_Centre/Typology == TypologyK/v/urban_centre);
			
			attribute<bool>        Result                                   (CompactedDomain) := IsLargeEnoughGroup && IsNotUrbanCentre;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/Dense_Urban_Cluster : null_b;
		}
		
		

		// SEMI-DENSE URBAN CLUSTER: Typology 22 is defined as: all cells with a local population density of at least 300 people/km2 and with a local built-up area share of at least 0.03, or all cells with a local population density of at least 1,500 people/km2 or built-up area share of at least 0.5, clustered in a 4-connectivity object of at least 5,000 people, farther than 3 km from a typology 23 or typology 22, and are not typology 30 or typology 23
		container Semi_Dense_Urban_Cluster
		{
			container Parameters := Calculate_DegreeOfUrbanisation/Parameters/Semi_Dense_Urban_Cluster;

			attribute<bool>        Has_Min_PopDensity_low                   (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density_low;
			attribute<bool>        Has_Min_PopDensity_high                  (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density_high;
			attribute<bool>        Has_Min_BUShare_low                      (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_BU_Share_low; 
			attribute<bool>        Has_Min_BUShare_high                     (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_BU_Share_high; 
			
			attribute<bool>        IsDenseEnoughAndBuiltupEnough_low        (CompactedDomain) := Has_Min_PopDensity_low && Has_Min_BUShare_low;
			attribute<bool>        IsDenseEnoughOrBuiltupEnough_high        (CompactedDomain) := Has_Min_PopDensity_high || Has_Min_BUShare_high;
			
			attribute<bool>        IsDenseEnoughAndOrBuiltUpEnough_Combined (CompactedDomain) := IsDenseEnoughAndBuiltupEnough_low || IsDenseEnoughOrBuiltupEnough_high;
			
			unit<uint32> FindContiguousCells := district(uint8(recollect_by_cond(domain/IsCompactedDomain, IsDenseEnoughAndOrBuiltUpEnough_Combined)))
			{
				attribute<.>       GroupDomain_rel                                   (domain) := districts;
				attribute<uint32>  GroupCellSize                                     (domain) := pcount_uint32(districts)[GroupDomain_rel];
				attribute<Person>  Sum_Population_perGroup                                    := sum(Population_domain,GroupDomain_rel);
				attribute<Person>  GroupPopulationSize                               (domain) := GroupCellSize != max(GroupCellSize) ? Sum_Population_perGroup[GroupDomain_rel] : null_f;
			}
			
			attribute<bool>        IsLargeEnoughGroup                       (CompactedDomain) := FindContiguousCells/GroupPopulationSize[CompactedDomain/domain_rel] >= Parameters/Min_Total_Pop;
			attribute<bool>        IsNotOtherTypology                       (CompactedDomain) := NOT(
																									Urban_Centre/Typology == TypologyK/v/urban_centre 
																									|| Dense_Urban_Cluster/Typology == TypologyK/v/Dense_Urban_Cluster
																								);
			attribute<bool>        IsDUCorUC                                (CompactedDomain) := Urban_Centre/Result || Dense_Urban_Cluster/Result;
			attribute<bool>        IsFarEnoughFrom_DUC_UC                   (CompactedDomain) := sum_uint32(IsDUCorUC[DistMatrices/Cdomain_x_pot2k/third_rel], DistMatrices/Cdomain_x_pot2k/first_rel) == 0; 
			
			attribute<bool>        Result                                   (CompactedDomain) := IsLargeEnoughGroup && IsNotOtherTypology && IsFarEnoughFrom_DUC_UC;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/Semi_dense_urban_cluster : null_b;
		}
		
		// SUBURBAN GRID CELL: Typology 21 is defined as: all cells with a local population density of at least 300 people/km2 and with a local built-up area share of at least 0.03, or all cells with a local population density of at least 1,500 people/km2 or built-up area share of at least 0.5, clustered in a 4-connectivity object of at least 5,000 people, within than 3 km from a typology 23 or typology 22, and are not typology 30 or typology 23
		container Suburban_Grid_Cell
		{
			container Parameters := Calculate_DegreeOfUrbanisation/Parameters/Suburban_Grid_Cell;

			attribute<bool>        Has_Min_PopDensity_low                   (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density_low;
			attribute<bool>        Has_Min_PopDensity_high                  (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density_high;
			attribute<bool>        Has_Min_BUShare_low                      (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_BU_Share_low; 
			attribute<bool>        Has_Min_BUShare_high                     (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_BU_Share_high; 
			
			attribute<bool>        IsDenseEnoughAndBuiltupEnough_low        (CompactedDomain) := Has_Min_PopDensity_low && Has_Min_BUShare_low;
			attribute<bool>        IsDenseEnoughOrBuiltupEnough_high        (CompactedDomain) := Has_Min_PopDensity_high || Has_Min_BUShare_high;
			
			attribute<bool>        IsDenseEnoughAndOrBuiltUpEnough_Combined (CompactedDomain) := IsDenseEnoughAndBuiltupEnough_low || IsDenseEnoughOrBuiltupEnough_high;
			
			attribute<bool>		   crit_domain (domain):= recollect_by_cond(domain/IsCompactedDomain, IsDenseEnoughAndOrBuiltUpEnough_Combined);

			unit<uint32> FindContiguousCells := district(uint8(recollect_by_cond(domain/IsCompactedDomain, IsDenseEnoughAndOrBuiltUpEnough_Combined)))
			{
				attribute<.>       GroupDomain_rel                                   (domain) := districts;
				attribute<uint32>  GroupCellSize                                     (domain) := pcount_uint32(districts)[GroupDomain_rel];
				attribute<Person>  Sum_Population_perGroup                                    := sum(crit_domain ? Population_domain : 0[Person],GroupDomain_rel);
				attribute<Person>  GroupPopulationSize                               (domain) := GroupCellSize != max(GroupCellSize) ? Sum_Population_perGroup[GroupDomain_rel] : null_f;
			}
			
			attribute<bool>        IsLargeEnoughGroup                       (CompactedDomain) := FindContiguousCells/GroupPopulationSize[CompactedDomain/domain_rel] >= Parameters/Min_Total_Pop;
			
			attribute<bool>        IsDUCorSDUC                              (CompactedDomain) := Dense_Urban_Cluster/Result || Semi_Dense_Urban_Cluster/Result;
			attribute<bool>        IsCloseEnoughTo_DUC_SDUC                 (CompactedDomain) := sum_uint32(IsDUCorSDUC[DistMatrices/cdomain_x_pot3k/third_rel], DistMatrices/cdomain_x_pot3k/first_rel) > 0; 
			
			attribute<bool>        IsNotOtherTypology                       (CompactedDomain) := NOT(
																									Urban_Centre/Typology == TypologyK/v/Urban_Centre 
																									|| Dense_Urban_Cluster/Typology == TypologyK/v/Dense_Urban_Cluster
																								);
			
			attribute<bool>        Result                                   (CompactedDomain) := IsLargeEnoughGroup && IsCloseEnoughTo_DUC_SDUC && IsNotOtherTypology;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/Suburban_Grid_Cell : null_b;
		}
		
		// RURAL CLUSTER: Typology 13 is defined as: all cells with a local population density of at least 300 people/km2 or with a local built-up area share of at least 0.50, and clustered in a 4-connectivity object of at least 500 people and are not typology 30 or typology 2X
		container Rural_Cluster
		{
			container Parameters := Calculate_DegreeOfUrbanisation/Parameters/Rural_Cluster;
			
			attribute<bool>        Has_Min_PopDensity                       (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density;
			attribute<bool>        Has_Min_BUShare                          (CompactedDomain) := BuiltUp_Total_Area / Land_Area >= Parameters/Min_BU_Share; 
			attribute<bool>        IsDenseEnoughOrBuiltupEnough             (CompactedDomain) := Has_Min_PopDensity || Has_Min_BUShare;
			
			unit<uint32> FindContiguousCells := district(uint8(recollect_by_cond(domain/IsCompactedDomain, IsDenseEnoughOrBuiltupEnough && IsNotOtherTypology)))
			{
				attribute<.>       GroupDomain_rel                                   (domain) := districts;
				attribute<uint32>  GroupCellSize                                     (domain) := pcount_uint32(districts)[GroupDomain_rel];
				attribute<Person>  Sum_Population_perGroup                                    := sum(Population_domain, GroupDomain_rel);
				attribute<Person>  GroupPopulationSize                               (domain) := GroupCellSize != max(GroupCellSize) ? Sum_Population_perGroup[GroupDomain_rel] : null_f;
			}
			
			attribute<bool>        IsLargeEnoughGroup                       (CompactedDomain) := FindContiguousCells/GroupPopulationSize[CompactedDomain/domain_rel] >= Parameters/Min_Total_Pop;
			
			attribute<bool>        IsNotOtherTypology                       (CompactedDomain) := NOT(
																									Urban_Centre/Typology == TypologyK/v/urban_centre 
																									|| Dense_Urban_Cluster/Typology == TypologyK/v/Dense_Urban_Cluster
																									|| Semi_Dense_Urban_Cluster/Typology == TypologyK/v/Semi_Dense_Urban_Cluster
																									|| Suburban_Grid_Cell/Typology == TypologyK/v/Suburban_Grid_Cell
																								);
			
			attribute<bool>        Result                                   (CompactedDomain) := IsLargeEnoughGroup && IsNotOtherTypology;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/Rural_Cluster : null_b;
		}
		
		// LOW DENSITY RURAL GRID CELL: Typology 12 is defined as: all cells with a local population density of at least 50 people/km2 and are not typology 30 or typology 2X or typology 13
		container Low_Density_Rural_Grid_Cell
		{
			container Parameters := Calculate_DegreeOfUrbanisation/Parameters/Low_Density_Rural_Grid_Cell;
			
			attribute<bool>        Has_Min_PopDensity                       (CompactedDomain) := Population_Land_Density >= Parameters/Min_Density;
			attribute<bool>        IsNotOtherTypology                       (CompactedDomain) := NOT(
																									Urban_Centre/Typology == TypologyK/v/urban_centre 
																									|| Dense_Urban_Cluster/Typology == TypologyK/v/Dense_Urban_Cluster
																									|| Semi_Dense_Urban_Cluster/Typology == TypologyK/v/Semi_Dense_Urban_Cluster
																									|| Suburban_Grid_Cell/Typology == TypologyK/v/Suburban_Grid_Cell
																									|| Rural_Cluster/Typology == TypologyK/v/Rural_Cluster
																								);
																				
			attribute<bool>        Result                                   (CompactedDomain) := Has_Min_PopDensity && IsNotOtherTypology;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/Low_Density_Rural_Grid_Cell : null_b;
		}

		// VERY LOW DENSITY GRID CELL: Typology 11 is defined as: all cells that are on land and are not typology 30 or typology 2X or typology 13 or typology 12
		container Very_Low_Density_Grid_Cell
		{
			// container Parameters := DegreeOfUrbanisation/Parameters/Very_Low_Density_Grid_Cell;
			
			attribute<bool>        IsOnLand                                 (CompactedDomain) := /SourceData/Physical/Coast/Coastline/Read_per_grid[CompactedDomain/domain_rel];
			attribute<bool>        IsNotOtherTypology                       (CompactedDomain) := NOT(
																									Urban_Centre/Typology == TypologyK/v/urban_centre 
																									|| Dense_Urban_Cluster/Typology == TypologyK/v/Dense_Urban_Cluster
																									|| Semi_Dense_Urban_Cluster/Typology == TypologyK/v/Semi_Dense_Urban_Cluster
																									|| Suburban_Grid_Cell/Typology == TypologyK/v/Suburban_Grid_Cell
																									|| Rural_Cluster/Typology == TypologyK/v/Rural_Cluster
																									|| Low_Density_Rural_Grid_Cell/Typology == TypologyK/v/Low_Density_Rural_Grid_Cell
																								);
																				
			attribute<bool>        Result                                   (CompactedDomain) := IsOnLand && IsNotOtherTypology;
			attribute<TypologyK>   Typology                                 (CompactedDomain) := Result ? TypologyK/v/Very_Low_Density_Grid_Cell : null_b;
		}
		
		
		attribute<TypologyK>       Typology                                 (CompactedDomain) := ='switch('+AsList('case('+TypologyK/name+'/Result, TypologyK/v/'+TypologyK/name+')', ',')+', null_b)';
		attribute<TypologyK>       Typology_Domain                                   (Domain) := recollect_by_cond(domain/IsCompactedDomain, Typology); // seems redundant, added because of the need to have this result in the grid distance access computations
		
		attribute<uint8>           StoreTypology                                     (domain) := TypologyK/EK[Typology_Domain], StorageName = "= '%localdataprojdir%/export/degurbagrids/'+ModelParameters/StudyArea+'/'+propvalue(., 'Name')+'.tif'";
		attribute<uint8>           ReadTypology                                      (domain) : StorageName = "=PropValue(StoreTypology, 'StorageName')", StorageReadOnly = "true";
		attribute<TypologyK>       ReadTypologyK                                     (domain) := invert(TypologyK/EK)[ReadTypology];
	}
}