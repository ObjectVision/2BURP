container Future : using = "units;geography;sourcedata/regionalunits;classifications"
{
	attribute<ClaimRegion>           Region_rel (CompactedDomain) := ClaimRegion/per_CompactedDomain;
	
	container InitialState 
	{
		attribute<BuiltUpKm2>        BuiltUp_Total_Area_domain               (domain) := ='SourceData/BuiltUp/Total/'+ModelParameters/StartYear+'[km2] / 1[km2] * 1[BuiltUpKm2]';
		attribute<BuiltUpKm2>        BuiltUp_Residential_Area_domain         (domain) := ='SourceData/BuiltUp/Residential/'+ModelParameters/StartYear+'[km2] / 1[km2] * 1[BuiltUpKm2]';
		attribute<BuiltUpKm2>        BuiltUp_NonResidential_Area_domain      (domain) := ='SourceData/BuiltUp/NonResidential/'+ModelParameters/StartYear+'[km2] / 1[km2] * 1[BuiltUpKm2]';
		attribute<float32>           BuiltUp_Total_Share_domain              (domain) := BuiltUp_Total_Area_domain / domain/area * 1[km2] / 1[BuiltUpKm2];
		attribute<Person>            Population_domain                       (domain) := ='SourceData/Population/PerYear/'+ModelParameters/StartYear+'[Person]';
		attribute<Person_BuiltUpKm2> Population_inRes_Density_domain         (domain) := Population_domain / BuiltUp_Residential_Area_domain; // DO NOT USE!
		attribute<Person_BuiltUpKm2> Population_inRes_Density_Trunc_domain   (domain) := min_elem_alldefined(Population_inRes_Density_domain, maxmax_saturation);
		attribute<Person>            Population_Trunc_domain                 (domain) := Population_inRes_Density_Trunc_domain * BuiltUp_Residential_Area_domain; //truncate for unrealistic densities (e.g. very much population in hardly any builtup area).
		
		attribute<BuiltUpKm2>        BuiltUp_Total_Area             (CompactedDomain) := BuiltUp_Total_Area_domain[CompactedDomain/org_rel]; 
		attribute<BuiltUpKm2>        BuiltUp_Residential_Area       (CompactedDomain) := BuiltUp_Residential_Area_domain[CompactedDomain/org_rel]; 
		attribute<BuiltUpKm2>        BuiltUp_NonResidential_Area    (CompactedDomain) := BuiltUp_NonResidential_Area_domain[CompactedDomain/org_rel]; 
		attribute<float32>           Builtup_Total_Share            (CompactedDomain) := BuiltUp_Total_Share_domain[CompactedDomain/org_rel];
		attribute<percentages> 		 Perc_BuiltUp_Total             (CompactedDomain) := classify(100f * (BuiltUp_Total_Share), id(percentages)[float32]);
		attribute<Person>            Population_org                 (CompactedDomain) := Population_domain[CompactedDomain/org_rel]; 
		attribute<Person_BuiltUpKm2> Population_inRes_Density_org   (CompactedDomain) := Population_org / BuiltUp_Residential_Area; // DO NOT USE!
		attribute<Person_BuiltUpKm2> Population_inTot_Density_org   (CompactedDomain) := Population_org / BuiltUp_Total_Area; // DO NOT USE!
		attribute<Person_BuiltUpKm2> Population_inRes_Density       (CompactedDomain) := min_elem_alldefined(Population_inRes_Density_org, maxmax_saturation);
		attribute<Person_BuiltUpKm2> Population_inTot_Density       (CompactedDomain) := min_elem_alldefined(Population_inTot_Density_org, maxmax_saturation);
		attribute<Person>            Population                     (CompactedDomain) := Population_inRes_Density * BuiltUp_Residential_Area; //truncate for unrealistic densities (e.g. very much population in hardly any builtup area).
		
		parameter<Person_BuiltUpKm2> maxmax_saturation                                := 1000000[Person_BuiltUpKm2];
		container PopulationDensity_8dir  := Preprocessing/Population_Neighbourhoods/Create_8dir_T((Population_Trunc_domain / domain/area)[float64]);
	}

	unit<uint32> ClaimRegion := FunctionalAreas 
	{
		attribute<Person>     Initial_Population_src           := sum(InitialState/Population_org, per_CompactedDomain);
		attribute<Person>     Initial_Population_Trunc         := sum(InitialState/Population, per_CompactedDomain);
		attribute<BuiltUpKm2> Initial_BuiltUp_Total_Area       := sum(InitialState/BuiltUp_Total_Area, per_CompactedDomain);
		attribute<BuiltUpKm2> Initial_BuiltUp_Residential_Area := sum(InitialState/BuiltUp_Residential_Area, per_CompactedDomain);
	}

	container Claim
	{
		container Builtup    := Preprocessing/Claims_BuiltUp;
		container Population := Preprocessing/Claims_Population;
	}

	container Allocate_Builtup := 
		for_each_ne(
			ProjectionYears/name 
			,	'Allocate_Builtup_T('
					+quote(ProjectionYears/name)+                              // (0) Year
					', Allocate_Builtup/'+ProjectionYears/prevStateName+       // (1) State builtup of previous period
					', Allocate_Population/'+ProjectionYears/prevStateName+    // (2) State population of previous period (population_allocation container)
					', Claim/Builtup/'+ProjectionYears/name+                   // (3) Expected amount of builtup per region in km2
				')'
		) 
	{
		container InitialState:= Future/InitialState;
	}
		
	container Allocate_Population := 
		for_each_ne(
			ProjectionYears/name 
			,	'Allocate_Population_T('
					+quote(ProjectionYears/name)+
					','+ProjectionYears/prevStateName+
					', Allocate_Builtup/'+ProjectionYears/name+'/NewState'
					', Claim/Population/'+ProjectionYears/name+
				')'
		) 
	{
		container InitialState:= Future/InitialState;
	}

	container Indicators
	{
		container Prep
		{
			container Population := 
				for_each_nedv(
					ProjectionYears/name
					, 'recollect_by_cond(domain/IsCompactedDomain, Allocate_Population/'+ProjectionYears/name+'/NewState/Population)'
					, domain
					, Person
				)
			{
				attribute<Person> D_2030_2100 (domain) := Y2100 - Y2030;
			}
				
			container BuiltUp_Total_Area := 
				for_each_nedv(
					ProjectionYears/name
					, 'recollect_by_cond(domain/IsCompactedDomain, Allocate_Builtup/'+ProjectionYears/name+'/NewState/BuiltUp_Total_Area)'
					, domain
					, BuiltUpKm2
				);
				
			container Delta_BuiltUp_Total_Area := 
				for_each_nedv(
					ProjectionYears_Delta/name
					, 'BuiltUp_Total_Area/'+ProjectionYears_Delta/name+' - BuiltUp_Total_Area/'+ProjectionYears_Delta/prev_name
					, domain
					, BuiltUpKm2
				);
				
			container BuiltUp_Total_Share := 
				for_each_nedv(
					ProjectionYears/name
					, 'recollect_by_cond(domain/IsCompactedDomain, Allocate_Builtup/'+ProjectionYears/name+'/NewState/BuiltUp_Total_Share)'
					, domain
					, float32
				);
				
			container BuiltUp_Residential_Area := 
				for_each_nedv(
					ProjectionYears/name
					, 'recollect_by_cond(domain/IsCompactedDomain, Allocate_Builtup/'+ProjectionYears/name+'/NewState/BuiltUp_Residential_Area)'
					, domain
					, BuiltUpKm2
				);
				
			container Population_InRes_Density := 
				for_each_nedv(
					ProjectionYears/name
					, 'recollect_by_cond(domain/IsCompactedDomain, Allocate_Population/'+ProjectionYears/name+'/NewState/Population_inRes_Density)'
					, domain
					, Person_BuiltUpKm2
				);
			container Population_Onland_Density := 
				for_each_nedv(
					ProjectionYears/name
					, 'recollect_by_cond(domain/IsCompactedDomain, Allocate_Population/'+ProjectionYears/name+'/NewState/Population_TotalLand_Density)'
					, domain
					, Person_Km2
				);
			container DegreesOfUrbanisation :=
				for_each_ne(
					ProjectionYears/name
					, 'Preprocessing/Calculate_DegreeOfUrbanisation/Gen_T(
							  recollect_by_cond(domain/IsCompactedDomain, Allocate_Builtup/'+ProjectionYears/name+'/NewState/BuiltUp_Total_Area)
							, recollect_by_cond(domain/IsCompactedDomain, Allocate_Builtup/'+ProjectionYears/name+'/NewState/BuiltUp_Residential_Area)
							, recollect_by_cond(domain/IsCompactedDomain, Allocate_Population/'+ProjectionYears/name+'/NewState/Population))'
				)
			{
			}
			parameter<string> Generate_DegreesOfUrbanisation := 'Ready', ExplicitSuppliers = "=AsList('DegreesOfUrbanisation/'+ProjectionYears/name+'/StoreTypology', ';')";
		}

		
		container Added_BU_perDoU2020 := 
			for_each_nedv(
				ProjectionYears_Delta/name
				, 'sum(Prep/Delta_BuiltUp_Total_Area/'+ProjectionYears_Delta/name+', Preprocessing/DegreesOfUrbanisation/Y2020/ReadTypologyK)'
				, TypologyK
				, BuiltUpKm2
			)
		{
			attribute<string>  Label     (TypologyK) := TypologyK/label;
		}
		
		// Future change in population per degree of urbanisation class.
		container Population_perDoU := 
			for_each_nedv(
				ProjectionYears/name
				, 'sum(Prep/Population/'+ProjectionYears/name+', Prep/DegreesOfUrbanisation/'+ProjectionYears/name+'/ReadTypologyK)'
				, TypologyK
				, Person
			)
		{
			attribute<string>  Label     (TypologyK) := TypologyK/label;
		}
		
		// Compare histograms of BU, Population, and density per FA between time steps (2000-2020-2050-2100). Do they skew?		
		unit<uint8> Population_Histogram : nrofrows = 10
		{
			attribute<string>  Label             := 'LB_'+string(ClassBreaks);
			attribute<float32> ClassBreaks       : [0, 1, 25, 50, 100, 500, 1000, 2000, 3000, 5000];
			
			container PerYear := 
				for_each_nedv(
					ProjectionYears/name
					, 'pcount(Classify(Prep/Population/'+ProjectionYears/name+', ClassBreaks))'
					, .
					, uint32
				)
			{
				attribute<string>  Label     (..) := ../label;
			}
 		}
				
		container BuiltUp_Percentages_Histogram := 
			for_each_nedv(
				ProjectionYears/name
				, 'pcount(Allocate_Builtup/'+ProjectionYears/name+'/NewState/Perc_BuiltUp_Total)'
				, percentages
				, uint32
			) {
				attribute<uint32> Y2020 (percentages):= pcount(InitialState/Perc_BuiltUp_Total);
			}
		unit<uint8> Population_InRes_Density_Histogram : nrofrows = 10
		{
			attribute<string>  Label             := 'LB_'+string(ClassBreaks);
			attribute<float32> ClassBreaks       : [0, 1, 250, 500, 1000, 3000, 4000, 5000, 7500, 10000];
			
			container PerYear := 
				for_each_nedv(
					ProjectionYears/name
					, 'pcount(Classify(Prep/Population_inRes_Density/'+ProjectionYears/name+', ClassBreaks))'
					, .
					, uint32
				)
			{
				attribute<string>  Label     (..) := ../label;
			}
 		}
		
		unit<uint8> Population_OnLand_Density_Histogram : nrofrows = 10
		{
			attribute<string>  Label             := 'LB_'+string(ClassBreaks);
			attribute<float32> ClassBreaks       : [0, 1, 250, 500, 1000, 3000, 4000, 5000, 7500, 10000];
			
			container PerYear := 
				for_each_nedv(
					ProjectionYears/name
					, 'pcount(Classify(Prep/Population_Onland_Density/'+ProjectionYears/name+', ClassBreaks))'
					, .
					, uint32
				)
			{
				attribute<string>  Label     (..) := ../label;
			}
 		}
		
		unit<uint8> BuiltUp_Residential_Area_Histogram : nrofrows = 10
		{
			attribute<string>  Label             := 'LB_'+string(ClassBreaks);
			attribute<float32> ClassBreaks       : [0, 0.0001, 0.001, 0.01, 0.05, 0.075, 0.1, 0.15, 0.2, 0.25];
			
			container PerYear := 
				for_each_nedv(
					ProjectionYears/name
					, 'pcount(Classify(Prep/BuiltUp_Residential_Area/'+ProjectionYears/name+', ClassBreaks))'
					, .
					, uint32
				)
			{
				attribute<string>  Label     (..) := ../label;
			}
 		}
		
		unit<uint8> BuiltUp_Total_Share_Histogram : nrofrows = 10
		{
			attribute<string>  Label             := 'LB_'+string(ClassBreaks);
			attribute<float32> ClassBreaks       : [0, 0.0001, 0.001, 0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25];
			
			container PerYear := 
				for_each_nedv(
					ProjectionYears/name
					, 'pcount(Classify(Prep/Builtup_Total_Share/'+ProjectionYears/name+', ClassBreaks))'
					, .
					, uint32
				)
			{
				attribute<string>  Label     (..) := ../label;
			}
 		}
	}
	
	
	
	Template Allocate_Builtup_T
	{
		parameter<string>     ThisYear;
		container             CurrState;
		container             CurrPopState;
		attribute<BuiltUpKm2> Claim (ClaimRegion);
		//
		parameter<float32> r_if_LocalMax    := 0.11f;
		parameter<float32> r_if_notLocalMax := 0.06f;
		parameter<float32> r_if_notBU       := 0.02f;
		parameter<float32> max_saturation   := 0.50f;
		
		container LocalMaxima
		{
			attribute<float32> Current_LocalMaximum_Share (CompactedDomain) := max(CurrState/BuiltUp_Total_Share[cdomain_x_pot1k/third_rel], cdomain_x_pot1k/first_rel); 
			attribute<bool>    IsLocalMaximum             (CompactedDomain) := Current_LocalMaximum_Share == CurrState/BuiltUp_Total_Share;
			attribute<bool>    HasNoBuiltUp               (CompactedDomain) := CurrState/BuiltUp_Total_Share == 0f;
			
			// If a cell has the highest local share of built-up area in T1, it can only increase by 11 pp in T2 (or by 50% - local share if this is smaller than 11 pp)
			// If a cell is built-up but it doesn’t have the highest local share of built-up area in T1, it can only increase in T2 to the local maximum in T1 + 6 pp (or by 50% - local share, if this is smaller than local maximum in T1 + 6 pp)
			// If a cell is not built-up in T1, it can only increase by 2 pp in T2
			attribute<float32> MaxAllowed_Builtup_Total_Share0   (CompactedDomain) := 
				iif(HasNoBuiltUp
					, r_if_notBU
					, median(max_saturation, CurrState/BuiltUp_Total_Share, CurrState/BuiltUp_Total_Share + (LocalMaxima/IsLocalMaximum ? r_if_LocalMax: r_if_notLocalMax))
				);
				
			attribute<float32> MaxAllowed_Builtup_Total_Share_extraRestrictie   (CompactedDomain) := (26.605f * exp(-0.047f*CurrState/BuiltUp_Total_Share*100f)) / 100f + CurrState/BuiltUp_Total_Share;
			attribute<float32> MaxAllowed_Builtup_Total_Share                   (CompactedDomain) := min_elem(MaxAllowed_Builtup_Total_Share_extraRestrictie, MaxAllowed_Builtup_Total_Share0);
			
			//adhoc
			attribute<float32> Diff (CompactedDomain) := MaxAllowed_Builtup_Total_Share0 - MaxAllowed_Builtup_Total_Share_extraRestrictie;
		}
		
		container BuiltUp_Density_Distribution
		{
			container Per_ClaimRegion := 
				for_each_ne(
					ClaimRegion/item_name
					, 'BuiltUp_Density_Distribution_Per_ClaimRegion_T('+string(id(ClaimRegion))+'[ClaimRegion], CurrState/Builtup_Total_Share)'
				);
				
			container Initial :=
				for_each_nedv(
					ClaimRegion/item_name
					, 'Per_ClaimRegion/'+ClaimRegion/item_name+'/DensityBins/density'
					, BU_DensityBins
					, float32
				)
			{
				attribute<string>  Label    (BU_DensityBins) := BU_DensityBins/label;
				attribute<float32> Average  (BU_DensityBins) := ='add('+AsItemList(ClaimRegion/item_name)+') / float32(#ClaimRegion)';
			} 
			
			parameter<float32> nroftimestepsleft := max_elem(float32(max(id(ProjectionYears)) - rlookup(ThisYear, ProjectionYears/name)), 1f);
			
			container Convergence :=
				for_each_nedv(
					ClaimRegion/item_name
					, 'Initial/'+ClaimRegion/item_name+' + ((Initial/Average - Initial/'+ClaimRegion/item_name+') / nroftimestepsleft)'
					, BU_DensityBins
					, float32
				)
			{
				attribute<string>  Label    (BU_DensityBins) := BU_DensityBins/label;
				attribute<float32> Average  (BU_DensityBins) := ='add('+AsItemList(ClaimRegion/item_name)+') / float32(#ClaimRegion)';
			} 
		}
		
		container Suitability
		{
			container        AutoGLM_Coeffs            := Analysis/Calibration/ReadCoffecients/coef2domain/domain;
		// attribute<Suit> Calc (domain) := ='(Preprocessing/Population_Neighbourhoods/PopulationDensity_8dir_StartYear/Ln_mean_8dir[float32]                                                                            * AutoGLM_Coeffs/PopulationDensity_2000_8dir) + '
		attribute<Suit> Calc (domain) := ='(CurrPopState/PopulationDensity_8dir/Ln_mean_8dir[float32]                                                                            * AutoGLM_Coeffs/PopulationDensity_2000_8dir) + '
																	'(min_elem(Physical/Coast/Location2Coast_km/ReadData[float32],250f)                                            * AutoGLM_Coeffs/Distance2Coastline) + 
																	(min_elem(Physical/Water/AllWater/Dist_LargeInland_km/GridData[float32],250f)                                 * AutoGLM_Coeffs/Distance2LargeInlandWater) + 
																	(min_elem(Socioeconomic/Infrastructure/Road/GRIP4_grid/Road123/Road123[float32],250f)                         * AutoGLM_Coeffs/Distance2MajorRoads) + 
																	(min_elem(Socioeconomic/Infrastructure/Road/GRIP4_grid/Road45/Road45[float32],250f)                           * AutoGLM_Coeffs/Distance2SecundaryRoads) + 
																	(min_elem(Socioeconomic/TravelTime/TravelTime[float32],100f)                                                  * AutoGLM_Coeffs/Road_distance_atleast_to_cities) + 
																	(Physical/Elevation/Elevation[float32]                                                                        * AutoGLM_Coeffs/Elevation) + 
																	(Physical/Slope_2021/ReadData[float32]                                                                        * AutoGLM_Coeffs/Slope) + 
																	(Physical/TerrainRoughnessIndex/TRI_Class_mean_1k[float32]                                                    * AutoGLM_Coeffs/TRI_mean) + 
																	(Policy/ProtectedAreas/ReadData[float32]                                                                      * AutoGLM_Coeffs/IsProtectedArea) + 
																	(Physical/Water/FloodProneArea/RP100/ReadData[float32]                                                        * AutoGLM_Coeffs/IsFloodProneArea_RP100) + 
																	(Physical/Natural_Hazards/Earthquake/Earthquakes_Modified_Mercalli_Intensity/ReadData[float32]                * AutoGLM_Coeffs/Earthquakes_MMI_Index) + 
																	((Physical/Natural_Hazards/Landslide/Frequency_of_landslides_triggered_by_precipitations/LS_pr_uint8[float32] + 
																		Physical/Natural_Hazards/Landslide/Frequency_of_landslides_triggered_by_earthquakes/LS_EQ_uint8[float32]) * AutoGLM_Coeffs/NrOfLandslides_Precipitation_NrOfLandslides_Earthquakes) + 
																	AutoGLM_Coeffs/Constant';
					
			attribute<Suit>  BuiltUp (CompactedDomain) := Calc[CompactedDomain/org_rel];
		}
		
		container Claims
		{
			attribute<BuiltUpKm2>        Builtup                            (ClaimRegion) := Claim;
		}
		
		container NewState
		{
			attribute<SuitNeg>    Rank                     (CompactedDomain) := -1[SuitNeg / Suit] * Suitability/BuiltUp;
			attribute<BuiltUpKm2> Delta_Claim                  (ClaimRegion) := Claims/BuiltUp - sum(CurrState/BuiltUp_Total_Area, Region_rel);
			attribute<BuiltUpKm2> Weight                   (CompactedDomain) := max_elem((LocalMaxima/MaxAllowed_Builtup_Total_Share - CurrState/BuiltUp_Total_Share) * CompactedDomain/area / 1[km2] * 1[BuiltUpKm2], 0[BuiltUpKm2]);
			attribute<bool>       FeasibilityCheck             (ClaimRegion) := sum(Weight, region_rel) >= Delta_Claim;
			
			attribute<SuitNeg>    CuttingLine                  (ClaimRegion) := MakeDefined(
																				nth_element_weighted(
																					Rank                                // negative suitability
																					, Delta_Claim                       // delta claim in BuiltUpKm2
																					, Weight                            // per cell value that adds towards the claim in BuiltUpKm2
																					, Region_rel   // relation between grid domain and claim region
																				)
																				, max(Rank, Region_rel) // if no cuttingline is found, the maximum of the negative suitablity is chosen per claim region. In other words, making sure there is a value, albeit the least suitable location.
																			), IntegrityCheck = "FeasibilityCheck";
			attribute<bool>       WillBeBuiltUp             (CompactedDomain) := Rank < CuttingLine[Region_rel]; //If smaller or equal to, this could result in too much allocation. If just smaller than, and the suitability is not expressive enough, this could result in underrealisation.

			attribute<float32>    BuiltUp_Total_Share       (CompactedDomain) := WillBeBuiltUp ? max_elem(LocalMaxima/MaxAllowed_Builtup_Total_Share, CurrState/BuiltUp_Total_Share) : CurrState/BuiltUp_Total_Share; 
			attribute<BuiltUpKm2> BuiltUp_Total_Area        (CompactedDomain) := BuiltUp_Total_Share * CompactedDomain/area / 1[km2] * 1[BuiltUpKm2];
			attribute<BuiltUpKm2> BuiltUp_Residential_Area  (CompactedDomain) := BuiltUp_Total_Area - InitialState/BuiltUp_NonResidential_Area;
			attribute<percentages> Perc_BuiltUp_Total (CompactedDomain):= classify(100f * (BuiltUp_Total_Share), id(percentages)[float32]);

			attribute<float32>    Claim_Realisation             (ClaimRegion) := sum(BuiltUp_Total_Area, Region_rel) / Claims/BuiltUp; //Check if around 1.0
		}
	}
	
	Template Allocate_Population_T
	{
		parameter<string>  ThisYear;
		container          CurrState;
		container          NewState_BuiltUp;
		attribute<Person>  Claim (ClaimRegion);
		///
		parameter<float32> Initial_Population_Proportional_Reduction_Rate_base := 0.025f;
		parameter<float32> Initial_Population_Absolute_Reduction_Rate_base     := 0.025f;
		attribute<float32> Initial_Population_Proportional_Reduction_Rate (ClaimRegion) := ='Preprocessing/PercDelta_Claims_Population/'+ThisYear+' < 0f ? max_elem(abs(Preprocessing/PercDelta_Claims_Population/'+ThisYear+') * 2f, Initial_Population_Proportional_Reduction_Rate_base) : Initial_Population_Proportional_Reduction_Rate_base';
		attribute<float32> Initial_Population_Absolute_Reduction_Rate     (ClaimRegion) := ='Preprocessing/PercDelta_Claims_Population/'+ThisYear+' < 0f ? max_elem(abs(Preprocessing/PercDelta_Claims_Population/'+ThisYear+') * 2f, Initial_Population_Absolute_Reduction_Rate_base) : Initial_Population_Absolute_Reduction_Rate_base';
		
		
		container LocalMaxima
		{
			parameter<Person_BuiltUpKm2_decade>  r_if_LocalMax     := 7000[Person_BuiltUpKm2_decade]; //== 3500 person per km2 of land if 50% builtup. 
			parameter<Person_BuiltUpKm2_decade>  r_if_notLocalMax  := 5000[Person_BuiltUpKm2_decade]; //== 2500 person per km2 of land if 50% builtup. 
			parameter<Person_BuiltUpKm2_decade>  r_if_notPopulated := 7000[Person_BuiltUpKm2_decade];  //== 350 person per km2 of land if 50% builtup. 
			parameter<Person_BuiltUpKm2>         max_saturation    := 100000[Person_BuiltUpKm2];
			
			attribute<Person_BuiltUpKm2>  Current_LocalMaximum          (CompactedDomain) := max(CurrState/Population_inRes_Density[cdomain_x_pot1k/third_rel], cdomain_x_pot1k/first_rel); 
			attribute<bool>               IsLocalMaximum                (CompactedDomain) := Current_LocalMaximum == CurrState/Population_inRes_Density;
			attribute<bool>               HasNoPopulation               (CompactedDomain) := CurrState/Population == 0f;
			
			// If a cell has the highest local population in T1, it can only increase by 3.5K people in T2 (or by [100K - local pop] if this is smaller than 3.5K people)
			// If a cell is populated but it doesn’t have the highest local population in T1, it can only increase in T2 to the local maximum in T1 + 2.5K people (or by [100K - local pop] if this is smaller than the local maximum in T1 + 2.5K people) 
			// If a cell is not populated in T1, it can only increase by 350 people in T2
			attribute<Person_BuiltUpKm2>  MaxAllowed_Population_Density (CompactedDomain) := 
				iif(HasNoPopulation
					, r_if_notPopulated * 1[decade]
					, median(max_saturation, CurrState/Population_inRes_Density, CurrState/Population_inRes_Density + (LocalMaxima/IsLocalMaximum ? r_if_LocalMax: r_if_notLocalMax)  * 1[decade])
				);
				
			attribute<Person>             MaxAllowed_Population         (CompactedDomain) := MaxAllowed_Population_Density * NewState_BuiltUp/BuiltUp_Residential_Area;
		}
		
		container Claims
		{
			attribute<Person>            Population                         (ClaimRegion) := Claim;
		}
		
		container Suitability
		{
			container AutoGLM_Coeffs  := Analysis/Calibration/ReadCoffecients/coef2domain/domain;
			// attribute<Suit> Calc (domain) := ='(Preprocessing/Population_Neighbourhoods/PopulationDensity_8dir_StartYear/Ln_mean_8dir[float32]                                    * AutoGLM_Coeffs/PopulationDensity_2000_8dir) + '
			attribute<Suit> Calc (domain) := ='(CurrState/PopulationDensity_8dir/Ln_mean_8dir[float32]                                                                            * AutoGLM_Coeffs/PopulationDensity_2000_8dir) + '
																	'(min_elem(Physical/Coast/Location2Coast_km/ReadData[float32],250f)                                            * AutoGLM_Coeffs/Distance2Coastline) + 
																	(min_elem(Physical/Water/AllWater/Dist_LargeInland_km/GridData[float32],250f)                                 * AutoGLM_Coeffs/Distance2LargeInlandWater) + 
																	(min_elem(Socioeconomic/Infrastructure/Road/GRIP4_grid/Road123/Road123[float32],250f)                         * AutoGLM_Coeffs/Distance2MajorRoads) + 
																	(min_elem(Socioeconomic/Infrastructure/Road/GRIP4_grid/Road45/Road45[float32],250f)                           * AutoGLM_Coeffs/Distance2SecundaryRoads) + 
																	(min_elem(Socioeconomic/TravelTime/TravelTime[float32],100f)                                                  * AutoGLM_Coeffs/Road_distance_atleast_to_cities) + 
																	(Physical/Elevation/Elevation[float32]                                                                        * AutoGLM_Coeffs/Elevation) + 
																	(Physical/Slope_2021/ReadData[float32]                                                                        * AutoGLM_Coeffs/Slope) + 
																	(Physical/TerrainRoughnessIndex/TRI_Class_mean_1k[float32]                                                    * AutoGLM_Coeffs/TRI_mean) + 
																	(Policy/ProtectedAreas/ReadData[float32]                                                                      * AutoGLM_Coeffs/IsProtectedArea) + 
																	(Physical/Water/FloodProneArea/RP100/ReadData[float32]                                                        * AutoGLM_Coeffs/IsFloodProneArea_RP100) + 
																	(Physical/Natural_Hazards/Earthquake/Earthquakes_Modified_Mercalli_Intensity/ReadData[float32]                * AutoGLM_Coeffs/Earthquakes_MMI_Index) + 
																	((Physical/Natural_Hazards/Landslide/Frequency_of_landslides_triggered_by_precipitations/LS_pr_uint8[float32] + 
																		Physical/Natural_Hazards/Landslide/Frequency_of_landslides_triggered_by_earthquakes/LS_EQ_uint8[float32]) * AutoGLM_Coeffs/NrOfLandslides_Precipitation_NrOfLandslides_Earthquakes) + 
																	AutoGLM_Coeffs/Constant';
		
			attribute<Suit>              BuiltUp                        (CompactedDomain) := Calc[CompactedDomain/org_rel];
			attribute<Suit>              NonNegative                    (CompactedDomain) := max_elem(BuiltUp, 0[Suit]);
			attribute<Suit>              Population                     (CompactedDomain) := NonNegative;
		}
		
		
		container NewState
		{
			//Reduction step 1: All cells will lose 10% of their initial population. This proportional reduction has the biggest impact in dense cells.
			attribute<Person>            Proportional_Reducted_Population       (CompactedDomain) := CurrState/Population * (1f - Initial_Population_Proportional_Reduction_Rate[ClaimRegion/per_CompactedDomain]); 
			
			//Reduction step 2: All inhabited cells will lose up to a fixed (per functional area) number of persons of 10% of the initial average population of the inhabited grid cells. This absolute reduction will have the biggest impact on low-density cells.
			attribute<Person>            Population_for_Region                      (ClaimRegion) := sum(CurrState/Population, Region_rel);
			attribute<uint32>            NumberOfCellsWithPopulationPerRegion       (ClaimRegion) := sum_uint32(CurrState/Population > 0[Person], Region_rel);
			attribute<float32>           Average_Population_per_PopulatedCell       (ClaimRegion) := Population_for_Region / NumberOfCellsWithPopulationPerRegion[float32];
			attribute<Person>            Regional_Reduction_per_cell                (ClaimRegion) := Average_Population_per_PopulatedCell * Initial_Population_Absolute_Reduction_Rate;
			attribute<Person>            Reduced_Population                     (CompactedDomain) := max_elem(Proportional_Reducted_Population - Regional_Reduction_per_cell[Region_rel], 0[Person]);
			
			//Adding step 3: Newly built-up areas will be populated based on the initial local average built-up population density in a 3x3 or 5x5 cell radius
			attribute<Person>            Avg_Local_Population_inRes_Density_Num (CompactedDomain) := sum(CurrState/Population[cdomain_x_pot3k/third_rel], cdomain_x_pot3k/first_rel); 
			attribute<BuiltUpKm2>        Avg_Local_Population_inRes_Density_Den (CompactedDomain) := sum(BuiltUp_Residential_Area[cdomain_x_pot3k/third_rel], cdomain_x_pot3k/first_rel); 
			attribute<Person_BuiltUpKm2> Avg_Local_Population_inRes_Density     (CompactedDomain) := Avg_Local_Population_inRes_Density_Num / Avg_Local_Population_inRes_Density_Den; 
			attribute<BuiltUpKm2>        BuiltUp_Total_Area                     (CompactedDomain) := NewState_BuiltUp/BuiltUp_Total_Area; 
			attribute<BuiltUpKm2>        BuiltUp_Residential_Area               (CompactedDomain) := NewState_BuiltUp/BuiltUp_Residential_Area; 
			
			attribute<BuiltUpKm2>        New_BuiltUp_Area                       (CompactedDomain) := max_elem(BuiltUp_Total_Area - CurrState/BuiltUp_Total_Area, 0f); 
			attribute<Person>            Population_in_New_BuiltUp_Area         (CompactedDomain) := New_BuiltUp_Area * Avg_Local_Population_inRes_Density;

			//Adding step 4: To the population we add the difference between the maximum allowed density and the initial density, after scaling it by the suitability, augmented to meet functional area claims.
			attribute<Person>            Population_beforeAllocation            (CompactedDomain) := Reduced_Population + Population_in_New_BuiltUp_Area;
			attribute<float32>           Sum_Suitability                            (ClaimRegion) := sum(Suitability/Population * Room_for_Population_Normalised , Region_rel);
			attribute<Person>            Room_for_Population                    (CompactedDomain) := max_elem(LocalMaxima/MaxAllowed_Population - Population_beforeAllocation, 0f);
			attribute<float32>           Room_for_Population_Normalised         (CompactedDomain) := Rescale(Room_for_Population, 0f, 1f);
			attribute<Person>            RestClaim                                  (ClaimRegion) := max_elem(Claims/Population - sum(Population_beforeAllocation, Region_rel), 0[Person]);
			attribute<float32>           ScaleFactor_0                              (ClaimRegion) := RestClaim / Sum_Suitability; //Number of persons per suitability value. 
			
			attribute<Person>            Population_0                           (CompactedDomain) := ScaleFactor_0[Region_rel] * Suitability/Population; //for debug purposes, not really number of persons!
			attribute<bool>              Check_for_enough_suitable_locations        (ClaimRegion) := sum(Suitability/Population > 0f ? int32(Room_for_Population)[Person] : 0[Person], Region_rel) >= RestClaim; //for debug purposes
			
			unit<uint8> Iter := cat_range(0b,10b) //10 is too little for the Netherlands to meet the regional claim.
			{
				attribute<string> name      := 'Iter_'+string(id(.));
				attribute<string> prev_name := MakeDefined(name[sub_or_null(id(.),1b)]+'/ScaleFactor_new', 'ScaleFactor_0');
			}
			
			container Population_Allocation :=
				for_each_ne(
					Iter/name
					, 'Population_Allocation_T('+Iter/prev_name+')'
				)
			{
				container Last := =last(Iter/name);
			}
			
			Template Population_Allocation_T
			{
				attribute<float32>       ScaleFactor                  (ClaimRegion);
				///
				attribute<Person>        Population               (CompactedDomain) := min_elem(ScaleFactor[Region_rel] * Suitability/Population * Room_for_Population_Normalised, Room_for_Population);
				attribute<Person>        Population_rounded       (CompactedDomain) := int32(Population)[Person]; //we round here, to omit fractional people which can then reallocated in the next iter.
				attribute<Person>        Realisation                  (ClaimRegion) := sum(Population_rounded, Region_rel);
				attribute<float32>       RescaleFactor                (ClaimRegion) := RestClaim / Realisation; // We need to correct the scale factor to accomodate left over claims.
				attribute<float32>       ScaleFactor_new              (ClaimRegion) := ScaleFactor * RescaleFactor;
			}
			
			//Results  
			attribute<Person>            Population                   (CompactedDomain) := Population_Allocation/Last/Population_rounded + Population_beforeAllocation;
			attribute<Person_BuiltUpKm2> Population_inRes_Density     (CompactedDomain) := Population / BuiltUp_Residential_Area;
			attribute<Person_Km2>        Population_TotalLand_Density (CompactedDomain) := (Population / CompactedDomain/area);
			attribute<float32>           Final_ClaimRealisation       (ClaimRegion) := sum(Population, Region_rel) / Claims/Population;
			
			container PopulationDensity_8dir  := Preprocessing/Population_Neighbourhoods/Create_8dir_T(recollect_by_cond(domain/IsCompactedDomain, Population_TotalLand_Density)[float64]);
			
			container Diagnostics 
			{
				unit<uint32> Relevant_ClaimRegions:= select_with_org_rel(pcount(Region_rel) > 1000) 
				{
					attribute<uint32>   ncells                       := pcount(Region_rel)[org_rel];
					attribute<LatLong>  Geometry              (poly) := ClaimRegion/Geometry_LL[org_rel];
					attribute<Person>   Total_Pop_pool               := (Claims/Population - sum(Reduced_Population, Region_rel))[org_rel];
					attribute<Person>   Total_In_NewBuiltup          := sum(Population_in_New_BuiltUp_Area, Region_rel)[org_rel];
					attribute<float32>  Perc_Pop_pool_in_new_builtup := Total_In_NewBuiltup[float32] /  Total_Pop_pool[float32];
					attribute<float32>  Perc_Pop_in_new_builtup      := Total_In_NewBuiltup[float32] /  (Claims/Population[float32])[org_rel];
					attribute<float32>  Perc_New_BuiltUp             := sum(New_BuiltUp_Area[float32], Region_rel)[org_rel] / sum(BuiltUp_Total_Area[float32], Region_rel)[org_rel];
				}
			}
		}
	}
	
	Template BuiltUp_Density_Distribution_Per_ClaimRegion_T
	{
		parameter<ClaimRegion> ClaimRegion_rel;
		attribute<float32>     Builtup_Total_Share (CompactedDomain);
		///
		attribute<uint8>       Builtup_Total_Share_int (CompactedDomain) := ClaimRegion/per_CompactedDomain == ClaimRegion_rel ? uint8(Builtup_Total_Share * 100f) : null_b;
		
		attribute<BU_DensityBins> Classified              (CompactedDomain) := lookup(Builtup_Total_Share_int, AllShares/DensityBins_rel);
		
		unit<uint8> DensityBins := BU_DensityBins
		{
			attribute<uint32>  count   := pcount(Classified); 
			attribute<float32> density := float32(count) / float32(sum(count));
		}
	}
}
