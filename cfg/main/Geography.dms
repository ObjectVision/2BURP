container Geography : using = "units;SourceData/RegionalUnits"
{
	unit<dpoint> LatLong := ='subextent/LatLong_'+ModelParameters/StudyArea;
	unit<dpoint> LatLong_Base: SpatialReference = "EPSG:4326", DialogData = "wms_layer_latlong"
	{
		parameter<float32> ViewPortMinSize := 100f / 3600f;
		parameter<float32> PenWorldWidth   := 10f / 3600f, DialogType = "PenWorldWidth";
		parameter<float32> LabelWorldSize  := 10f / 3600f, DialogType = "LabelWorldSize";
	}
	
	unit<dpoint> WorldMollweide    : SpatialReference = "ESRI:54009";
	Unit<dpoint> SphericalMercator_base : SpatialReference = "EPSG:3857", DialogData = "tms_layer_osm_webmercator";
	Unit<dpoint> SphericalMercator := range(SphericalMercator_base, point(-16000000.0, -20000000.0),  point(16000000.0, 20000000.0));
	
	
	unit<ipoint> web_mercator_cell := gridset(SphericalMercator, point(SourceRasterFactor_in_eq_m, SourceRasterFactor_in_eq_m), point(-16000000.0, -20000000.0), ipoint)
	{
		attribute<LatLong>            ll_rel_rev := mapping(., LatLong);
		attribute<LatLong>            ll_rel     := point(pointcol(ll_rel_rev), pointrow(ll_rel_rev), LatLong);
		attribute<domain>              domain_rel := value(ll_rel, domain);
		attribute<km2>                Area    := domain_rel->area;
	}
	
	parameter<float64> SourceRasterFactor_in_eq_m := SourceRasterFactor * (40000000.0 / 360.0);
	parameter<float64> SourceRasterFactor    := 0.00833333333333333333333333333333333333333333333333333333333;
	parameter<float64> SourceRasterSubFactor := 5.0 / 3600.0;
	parameter<km> lengthdegree := 40000km / 360f; // 40075.017d/360d;//at Equator
	
	unit<ipoint> LatLong_mdegrees := gridset(LatLong, point(0.0000001, 0.0000001), point(0.0,0.0), ipoint);


	container subextent
	{
		unit<dpoint> LatLong_World                    := range(LatLong_Base, point(-90.0,-180.0), point(90.0, 180.0));

		//For fast testing with extent of 1 country (no other country within extent)
		unit<dpoint> LatLong_Iceland                  := range(LatLong_Base, point( 62.0, -25.0), point(68.0,-12.0));

		unit<dpoint> LatLong_Europe_Africa            := range(LatLong_Base, point(-51.0, -40.0), point(85.0, 71.0));
		unit<dpoint> LatLong_Europe_Africa_America    := range(LatLong_Base, point(-66.0, 170.0), point(85.0, 75.0));
		
		//continents
		unit<dpoint> LatLong_Europe                   := range(LatLong_Base, point( 29.0, -11.0), point(61.0, 30.0));
		unit<dpoint> LatLong_Africa                   := range(LatLong_Base, point(-47.0, -26.0), point( 38.0, 64.0));
		unit<dpoint> LatLong_Antarctica               := range(LatLong_Base, point(-90.0,-180.0), point(-11.0,180.0));
		unit<dpoint> LatLong_Asia                     := range(LatLong_Base, point(-13.0,-180.0), point( 82.0,180.0));
		unit<dpoint> LatLong_Australia_Oceania        := range(LatLong_Base, point(-56.0,-180.0), point( 29.0,180.0));
		unit<dpoint> LatLong_North_America            := range(LatLong_Base, point(  5.0,-180.0), point( 84.0,180.0));
		unit<dpoint> LatLong_South_America            := range(LatLong_Base, point(-56.0,-110.0), point( 18.0,-28.0));

		//countries
		unit<dpoint> LatLong_test                     := range(LatLong_Base, point(52.04, 5.04), point(52.06, 5.06));//De Meern - Netherlands. Only 4 cells
		unit<dpoint> LatLong_Utrecht                  := range(LatLong_Base, point( 51.8,  4.7), point(52.3, 5.7));
		unit<dpoint> LatLong_Netherlands              := range(LatLong_Base, point( 45.0, -2.0), point(54.0,11.0));
	}
	// #include <Subextent_Special.dms>
	// #include <Subextent_ISO3.dms>


	unit<wpoint> domain :=
		gridset(
			range(LatLong, 
				LowerBound(LatLong) + point(0.5 * SourceRasterFactor, 0.5 * SourceRasterFactor, LatLong), 
				UpperBound(LatLong) - point(0.5 * SourceRasterFactor, 0.5 * SourceRasterFactor, LatLong)
			)
			, point(-SourceRasterFactor, SourceRasterFactor, LatLong)
			, point(90d, -180d, LatLong)
			, wpoint
		)
	{
		// attribute<uint8> aidgrid              := const(1b,domain);
		// attribute<bool>  BaseGridBool         := IsDefined(CompactedDomain/BaseGrid);

		unit<uint16> rowset := range(uint16, pointrow(Lowerbound(domain)), pointrow(Upperbound(domain)))
		{
			attribute<float64> lat_top := pointrow( point(ID(rowset), const(0w, rowset), domain)[LatLong] );
			attribute<float64> lat_mid := lat_top  + 0.5 * pointrow(getprojectionfactor(domain)[LatLong]);

			attribute<Float32> lat_factor := Float32( cos(lat_mid * 2d*pi() / 360d ) );
			attribute<km2> area := (lat_factor * sqr(Float32(pointrow(getprojectionfactor(domain)[LatLong])) * lengthdegree));
		}

		unit<uint16>colset := range(uint16, pointcol(Lowerbound(domain)), pointcol(Upperbound(domain)))
		{
			attribute<float64> long_top := pointcol( point(const(0w, colset),ID(colset), domain)[LatLong] );
			attribute<float64> long_mid := long_top  + 0.5 * pointcol(getprojectionfactor(domain)[LatLong]);
		}

		// parameter<uint32> boundrange_c := uint32(PointCol(boundrange(domain)));

		attribute<rowset> row        := pointrow(ID(domain));
		attribute<colset> col_colset := pointcol(ID(domain));

		// attribute<uint32> col      := uint32(pointcol(ID(domain)));
		// attribute<uint32> rowcol   := uint32(row) * boundrange_c;
		// attribute<uint32> number   := (rowcol +col) + 1;
		// attribute<uint8>  one_grid := number > 0 ? 1b : 0b;

		attribute<Float32> lat_factor := rowset/lat_factor[row];

		attribute<Float64> lat   := rowset/lat_mid[row];
		attribute<Float64> long  := colset/long_mid[col_colset];

		attribute<km2> area           := rowset/area[row]; //use rowset area
	}

	unit<ipoint> domain_sub :=
		gridset(
			range(LatLong, 
				LowerBound(LatLong) + point(0.5 * SourceRasterSubFactor, 0.5 * SourceRasterSubFactor, LatLong), 
				UpperBound(LatLong) - point(0.5 * SourceRasterSubFactor, 0.5 * SourceRasterSubFactor, LatLong)
			)
			, point(-SourceRasterSubFactor, SourceRasterSubFactor, LatLong)
			, point(90d, -180d, LatLong)
			, ipoint
		)
	{
		attribute<domain> domain_rel := mapping(., domain);
	}
	
	container GridData : using = "SourceData/RegionalUnits"
	{
		attribute<Person> InitPopGrid         (domain) := ModelParameters/Method='M3' ? convert(SourceData/Population/M3/UrbanPopulation2010, Person) : convert(SourceData/Population/M1/Urban_pop_2010/UPopulation2010, Person);
		attribute<Person> InitPopGrid1990     (domain) := CompactedDomain/ISCD  ? SourceData/Population/Past/PastDates/Y1990 * Preprocessing/urban/BuiltUpBoolJRC_50prc/y1990[float32] :0f/0f;

		attribute<Person> InitTpopGrid        (domain) := ModelParameters/Method='M3' ? convert(SourceData/Population/M3/TotalPopulation2010, Person) : convert(SourceData/Population/M1/Urban_pop_2010/PopulationData, Person);
		attribute<Person> InitTpopGrid1990    (domain) := CompactedDomain/ISCD  ? SourceData/Population/Past/PastDates/Y1990 :0f/0f;

		attribute<Bool> InRegion              (domain) := IsDefined(Countries/Country_grid);
		attribute<Bool> HasPop                (domain) := InitTpopGrid > 0[Person];
		attribute<Bool> HasUrb                (domain) := IsDefined(Countries/Country_grid) ? ((Preprocessing/UrbanArea/UrbanArea2010/ReadData) > 0b) : false;

		attribute<bool> IsNotLake             (domain) := not(Water/Water_without_oceans/ReadData);
		attribute<bool> IsNotIce              (domain) := not(Physical/SnowIceCover/ReadData);

		attribute<Bool> InRegionHasPopHasUrb  (domain) := (InRegion || HasPop || HasUrb);//at file-level already present in country file 
		attribute<Bool> FreeLand              (domain) := InRegionHasPopHasUrb && (IsNotLake || HasUrb || HasPop) && (IsNotIce || HasUrb || HasPop), FreeData = "False";
	}
	
	unit<uint32> CompactedDomain := select_with_org_rel(GridData/FreeLand), label = "allocation domain", DialogType = "Map", DialogData = "BaseGrid"
	{
		attribute<uint32>       CD                    := const(1,.);
		attribute<domain>       domain_rel            := org_rel;
		attribute<.>            BaseGrid (domain)     := invert(domain_rel);
		attribute<int64>        ISCDint64 (domain)    := MakeDefined(BaseGrid[int64],-1[int64]);
		attribute<bool>         ISCD (domain)         := ISCDint64 = -1[int64] ? false : true;
		attribute<domain/rowset> row                  := domain/row[domain_rel];
		attribute<float32>      lat_factor           := domain/lat_factor[domain_rel];
		attribute<km2>          area                 := domain/rowset/area[row];

		attribute<Float64> lat_deg  := domain/lat [domain_rel];
		attribute<Float64> long_deg := domain/long[domain_rel];
		attribute<Float64> lat_rad  := lat_deg * ( pi() / 180.0);
		attribute<float64> sinlat   := sin(lat_rad);
		attribute<float64> mercator_y_rad := log(tan(0.25 * pi() + 0.5 * lat_rad));
		attribute<float64> mercator_y_deg := mercator_y_rad * (180.0 / pi());
		
		attribute<SphericalMercator> geometry_mer:= point(mercator_y_deg, long_deg, SphericalMercator);
		

		attribute<Countries/Country> Country_rel   := Countries/Country_grid[domain_rel];
		attribute<Continent> Continent_rel := Countries/Country/Continent_id_grid[domain_rel];
		attribute<World> World_rel     := Countries/Country/World_id_grid[domain_rel];

		attribute<LatLong> geometry_not_as_feature := org_rel[LatLong];
	}
	
	#include <wms_layer_latlong.dms>
	#include <tms_layer_osm_webmercator.dms>
}