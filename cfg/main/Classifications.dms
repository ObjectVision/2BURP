container Classifications : using = "units"
{
	unit<uint32> Iter : nrofrows = 8
	{
		attribute<string> name := 'I'+string(id(.));
		attribute<string> PrevPopName := MakeDefined(name[sub_or_null(ID(.),1)]+'/NextPop', 'CurrState/Pop');
	}

	unit<uint8> SSP: nrofrows = 5
	{
		attribute<uint8>   id    :=id(.);
		attribute<string>  Name  : ['SSP1','SSP2', 'SSP3', 'SSP4', 'SSP5'];
		attribute<string>  Label := Name;

		container V := for_each_nedv(Name, 'value('+string(ID(.))+',..)', void, .);
	}
	
	unit<uint8> SSP_Past : nrofrows = 1
	{
		attribute<string>  Name: ['SSPPast'];
		attribute<string>  Label := Name;

		container V := for_each_nedv(Name, 'value('+string(ID(.))+',..)', void, .);
	}	
	
	unit<uint8> ProjectionDate : nrofrows = 10
	{
		attribute<Year>   Yr: [ 2010, 2020, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100];
		attribute<string> name          := 'Y'+string(Yr);
		
		attribute<string> prev_name      := (id(.) >= 1b) ? name[id(.) - min_elem( id(.), 1b) ] : 'StartingYear';
		attribute<string> prevStateName  := (id(.) >= 1b) ? name[id(.) - min_elem( id(.), 1b) ]+'/NewState' : 'InitialState';
	}

	unit<uint8> ProjectionDate_Past : nrofrows = 3
	{
		attribute<Year>   Yr            : [ 1990, 2000, 2015];
		attribute<string> name          := 'Y'+string(Yr);
		attribute<string> prevStateName := MakeDefined(name[sub_or_null(ID(.),1b)]+'/NewState', 'InitialState');
	}
	
	#include <classification_prc.dms>
	#include <classification_urban_discrete.dms>
	#include <classification_urb.dms>
	#include <classification_GHS_SMOD_export.dms>
	#include <classification_PopClass.dms>
	#include <classification_suitability.dms>
}